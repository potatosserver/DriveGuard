<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="utf-8" />
  <title>3D 智能語音導航 (進階版)</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />

  <!-- MapLibre GL JS -->
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

  <!-- Google Fonts & Icons -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <style>
    /* --- 全域設定 --- */
    body { margin: 0; padding: 0; font-family: 'Roboto', sans-serif; overflow: hidden; background: #eee; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; z-index: 1; }
    
    .crosshair-cursor .maplibregl-canvas { cursor: crosshair !important; }

    /* --- 搜尋面板 --- */
    #search-panel {
        position: absolute; top: 16px; left: 50%; transform: translateX(-50%);
        width: 92%; max-width: 420px; z-index: 100; 
        background: rgba(255, 255, 255, 0.98);
        border-radius: 12px; 
        box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        padding: 12px; 
        display: flex; flex-direction: column; gap: 8px; 
        transition: top 0.4s cubic-bezier(0.4, 0.0, 0.2, 1);
    }

    .input-row { display: flex; align-items: center; gap: 10px; }
    
    .input-box {
        flex: 1; display: flex; align-items: center; 
        background: #f1f3f4; border-radius: 8px; padding: 4px 12px;
        transition: background 0.2s, box-shadow 0.2s;
    }
    .input-box:focus-within { background: #fff; box-shadow: 0 0 0 2px #4285F4; }
    .input-box input { 
        border: none; background: transparent; flex: 1; padding: 10px 0; 
        font-size: 16px; outline: none; color: #202124; 
    }
    
    .icon-btn { 
        padding: 10px; border-radius: 50%; cursor: pointer; color: #5f6368; 
        transition: all 0.2s; display: flex; align-items: center; justify-content: center;
    }
    .icon-btn:hover { background: rgba(0,0,0,0.05); color: #202124; }
    .icon-btn.active { color: #1a73e8; background: #e8f0fe; }
    
    #suggestions { 
        max-height: 220px; overflow-y: auto; display: none; margin-top: 5px; 
        border-top: 1px solid #eee; 
    }
    .suggestion-item { 
        padding: 12px 8px; cursor: pointer; border-radius: 4px; 
        display: flex; flex-direction: column; 
    }
    .suggestion-item:hover { background: #f8f9fa; }
    .s-title { font-weight: 500; color: #202124; font-size: 15px; }

    /* --- 底部導航面板 --- */
    #nav-footer {
        position: absolute; bottom: 0; left: 0; width: 100%; 
        background: white; z-index: 1000;
        border-top-left-radius: 24px; border-top-right-radius: 24px;
        box-shadow: 0 -4px 20px rgba(0,0,0,0.15); 
        transform: translateY(110%); 
        transition: transform 0.4s cubic-bezier(0.2, 0, 0, 1); 
        padding: 20px 20px 30px 20px; box-sizing: border-box;
    }
    #nav-footer.show { transform: translateY(0); }

    .nav-info-container { display: flex; justify-content: space-between; align-items: center; }
    .route-meta h1 { margin: 0; font-size: 26px; color: #1a73e8; font-weight: 700; }
    .route-meta span { color: #5f6368; font-size: 16px; font-weight: 500; }

    /* 主要按鈕樣式 */
    #btn-main-action {
        background: #1a73e8; color: white; border: none; 
        padding: 14px 32px; border-radius: 30px; 
        font-size: 16px; font-weight: 600; cursor: pointer; 
        box-shadow: 0 4px 10px rgba(26, 115, 232, 0.3);
        transition: transform 0.1s, background 0.2s;
        min-width: 120px;
    }
    #btn-main-action:active { transform: scale(0.96); }
    #btn-main-action.plan-mode { background: #009688; }
    #btn-main-action.nav-mode { background: #1a73e8; }
    #btn-main-action.preview-mode { background: #5f6368; }

    /* --- 導航指令卡 --- */
    #turn-instruction {
        position: absolute; top: 16px; left: 50%; transform: translateX(-50%);
        width: 92%; max-width: 420px; 
        background: #263238; 
        color: white; 
        padding: 16px; border-radius: 12px; 
        z-index: 1001; display: none; 
        box-shadow: 0 8px 20px rgba(0,0,0,0.4);
    }
    
    .turn-body { display: flex; align-items: flex-start; justify-content: space-between; }
    .turn-left { display: flex; align-items: center; gap: 16px; }
    .turn-icon-large { font-size: 48px; color: #fff; }
    
    .turn-text-group { display: flex; flex-direction: column; }
    #turn-dist { font-size: 26px; font-weight: 700; color: #4fc3f7; line-height: 1.2; }
    #turn-text { font-size: 18px; font-weight: 400; opacity: 0.9; margin-top: 4px; }

    .turn-actions { display: flex; gap: 8px; }
    .glass-btn { 
        background: rgba(255,255,255,0.15); border: none; color: white;
        width: 44px; height: 44px; border-radius: 50%; 
        cursor: pointer; display: flex; align-items: center; justify-content: center;
        transition: background 0.2s;
    }
    .glass-btn:hover { background: rgba(255,255,255,0.25); }

    /* --- 退出按鈕 --- */
    #btn-exit-nav {
        position: absolute; bottom: 40px; right: 20px; 
        background: #fff; color: #d93025;
        width: 60px; height: 60px; border-radius: 50%; 
        border: none; display: none;
        z-index: 1002; cursor: pointer; 
        align-items: center; justify-content: center; 
        box-shadow: 0 6px 16px rgba(0,0,0,0.2);
        transition: transform 0.2s;
    }
    #btn-exit-nav:hover { transform: scale(1.05); }

    /* --- 步驟詳情面板 --- */
    #steps-panel {
        position: absolute; bottom: 0; left: 0; width: 100%; height: 60%; 
        background: white; z-index: 2000; 
        border-top-left-radius: 20px; border-top-right-radius: 20px;
        transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        display: flex; flex-direction: column; box-shadow: 0 -10px 40px rgba(0,0,0,0.2);
    }
    #steps-panel.open { transform: translateY(0); }
    
    .steps-header { 
        padding: 18px 20px; border-bottom: 1px solid #f1f3f4; 
        display: flex; justify-content: space-between; align-items: center; 
        font-weight: 700; font-size: 18px; color: #202124;
    }
    .steps-list { flex: 1; overflow-y: auto; padding: 0; margin: 0; list-style: none; }
    .step-item { 
        padding: 16px 20px; border-bottom: 1px solid #f8f9fa; 
        display: flex; gap: 16px; align-items: center; 
    }
    .step-item.active { background: #e8f0fe; border-left: 4px solid #1a73e8; }
    .step-icon { color: #5f6368; }
    .step-text { flex: 1; font-size: 16px; color: #3c4043; line-height: 1.5; }
    .step-dist { color: #1a73e8; font-weight: 500; font-size: 14px; min-width: 60px; text-align: right; }

    /* --- Loading --- */
    #loading-indicator {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.95); padding: 20px 30px;
      border-radius: 12px; z-index: 3000; display: none; 
      box-shadow: 0 8px 24px rgba(0,0,0,0.2);
      text-align: center;
    }
    .spinner {
        border: 4px solid #f3f3f3; border-top: 4px solid #1a73e8;
        border-radius: 50%; width: 30px; height: 30px;
        animation: spin 1s linear infinite; margin: 0 auto 10px auto;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .loading-text { font-weight: 500; color: #555; }

    /* --- 導航專用大標記 (CSS Maker) --- */
    .nav-marker {
        width: 32px; height: 32px;
        background: #4285F4;
        border: 3px solid white;
        border-radius: 50%;
        box-shadow: 0 0 0 10px rgba(66, 133, 244, 0.3); /* 光暈效果讓它看起來更大 */
        display: flex; align-items: center; justify-content: center;
    }
    .nav-arrow {
        width: 0; height: 0;
        border-left: 8px solid transparent;
        border-right: 8px solid transparent;
        border-bottom: 14px solid white;
        transform: translateY(-2px);
    }

  </style>
</head>
<body class="crosshair-cursor-enabled">

<div id="map"></div>

<!-- 搜尋面板 -->
<div id="search-panel">
    <div class="input-row">
        <span class="material-icons" style="color:#1a73e8; font-size: 20px;">trip_origin</span>
        <div class="input-box">
            <input type="text" id="start-input" placeholder="起點 (預設我的位置)" oninput="handleInput('start', this.value)" />
        </div>
        <div class="icon-btn" id="btn-pick-start" onclick="togglePickMode('start')" title="地圖選點">
            <span class="material-icons">touch_app</span>
        </div>
        <div class="icon-btn" onclick="forceUserLocation()" title="GPS定位">
            <span class="material-icons">my_location</span>
        </div>
    </div>
    
    <div class="input-row" style="height: 10px;"></div>

    <div class="input-row">
        <span class="material-icons" style="color:#d93025; font-size: 20px;">place</span>
        <div class="input-box">
            <input type="text" id="end-input" placeholder="輸入目的地" oninput="handleInput('end', this.value)" />
        </div>
        <div class="icon-btn" id="btn-pick-end" onclick="togglePickMode('end')" title="地圖選點">
            <span class="material-icons">touch_app</span>
        </div>
        <div class="icon-btn" onclick="clearEnd()" title="清除">
            <span class="material-icons">close</span>
        </div>
    </div>
    
    <div id="suggestions"></div>
</div>

<!-- 底部導航面板 -->
<div id="nav-footer">
    <div class="nav-info-container">
        <div class="route-meta">
            <h1 id="route-time">準備中</h1>
            <span id="route-dist">請點擊規劃</span>
        </div>
        <button id="btn-main-action" onclick="handleMainAction()">規劃路徑</button>
    </div>
</div>

<!-- 導航指令卡 -->
<div id="turn-instruction">
    <div class="turn-body">
        <div class="turn-left">
            <span class="material-icons turn-icon-large" id="turn-icon">straight</span>
            <div class="turn-text-group">
                <div id="turn-dist">--</div>
                <div id="turn-text">--</div>
            </div>
        </div>
        <div class="turn-actions">
            <button class="glass-btn" onclick="openStepsPanel()" title="列表">
                <span class="material-icons">format_list_bulleted</span>
            </button>
            <button class="glass-btn" onclick="toggleVoice()" title="語音">
                <span class="material-icons" id="voice-icon">volume_up</span>
            </button>
        </div>
    </div>
</div>

<button id="btn-exit-nav" onclick="exitNavigationMode()">
    <span class="material-icons" style="font-size: 32px;">close</span>
</button>

<!-- 步驟詳情面板 -->
<div id="steps-panel">
    <div class="steps-header">
        <span>路徑詳情</span>
        <div class="icon-btn" onclick="closeStepsPanel()">
            <span class="material-icons">keyboard_arrow_down</span>
        </div>
    </div>
    <ul class="steps-list" id="steps-list-container"></ul>
</div>

<div id="loading-indicator">
    <div class="spinner"></div>
    <div class="loading-text" id="loading-text">路徑計算中...</div>
</div>

<script>
  const graphHopperKey = '7cb4eb19-e0f4-40a3-a5e0-f2c039366f32'; 
  const style3D = 'https://tiles.openfreemap.org/styles/liberty';

  // --- 全域變數 ---
  let map, geolocateControl;
  let startCoords = null, endCoords = null;
  let startMarker = null, endMarker = null;
  let navMarker = null; // 導航用的大標記
  
  let currentRoutePath = null; 
  let fullRouteCoords = []; // 原始完整路徑 (Array of [lng, lat])
  let isNavigating = false;
  let navLocationHandler = null;
  let activeSearchType = 'end';
  let pickMode = null; 
  let isVoiceEnabled = true;
  let lastSpokenText = "";
  let isRouteCalculated = false;
  let isRecalculating = false; // 避免重複觸發重新規劃

  // 導航用變數
  let currentInstructionIndex = 0;
  
  const synth = window.speechSynthesis;
  const loadingIndicator = document.getElementById('loading-indicator');
  const navFooter = document.getElementById('nav-footer');
  const stepsPanel = document.getElementById('steps-panel');
  const mainBtn = document.getElementById('btn-main-action');
  const routeTime = document.getElementById('route-time');
  const routeDist = document.getElementById('route-dist');

  function initMap() {
    map = new maplibregl.Map({
      container: 'map',
      style: style3D,
      center: [121.5, 25.04],
      zoom: 15,
      pitch: 0,
      bearing: 0,
      antialias: true
    });

    map.on('load', () => {
        // 定位控件 (UI)
        geolocateControl = new maplibregl.GeolocateControl({
            positionOptions: { enableHighAccuracy: true },
            trackUserLocation: true,
            showUserHeading: true
        });
        map.addControl(geolocateControl);
        
        // 初始觸發一次定位
        forceUserLocation();

        // **持續監聽位置更新 (Pre-navigation 邏輯)**
        geolocateControl.on('geolocate', (e) => {
            if (isNavigating) return; // 導航中有專用的 Handler

            const userCoords = { lng: e.coords.longitude, lat: e.coords.latitude };
            
            // 如果輸入框是 "我的位置"，則即時更新 startCoords
            const startInput = document.getElementById('start-input');
            if (startInput.value === "我的位置") {
                startCoords = userCoords;
                // 如果已經規劃過，但還沒導航，可以在這裡選擇是否要重算 (選填，目前保持手動按規劃)
            }
        });

        map.on('click', (e) => {
            if (pickMode) {
                if (pickMode === 'start') setStartPoint(e.lngLat, "地圖已選點");
                else if (pickMode === 'end') setEndPoint(e.lngLat, "地圖已選點");
                togglePickMode(null);
            }
        });
    });
  }

  // ==========================================
  // 核心功能: 路徑規劃
  // ==========================================
  async function calculateRoute(startLoc = startCoords) {
      if (!startLoc || !endCoords) return;
      if (isRecalculating) return; // 防止重複

      loadingIndicator.style.display = 'block';
      document.getElementById('loading-text').innerText = isNavigating ? "偏離路徑，重新規劃中..." : "路徑計算中...";
      mainBtn.disabled = true;

      const params = new URLSearchParams();
      params.append('key', graphHopperKey);
      params.append('profile', 'car');
      params.append('locale', 'zh-TW');
      params.append('elevation', 'false');
      params.append('instructions', 'true');
      params.append('points_encoded', 'false'); 
      params.append('point', `${startLoc.lat},${startLoc.lng}`);
      params.append('point', `${endCoords.lat},${endCoords.lng}`);

      try {
          const res = await fetch(`https://graphhopper.com/api/1/route?${params.toString()}`);
          if (!res.ok) throw new Error("API Error");
          const data = await res.json();
          
          if (data.paths && data.paths.length > 0) {
              const path = data.paths[0];
              currentRoutePath = path;
              fullRouteCoords = path.points.coordinates;
              
              // 繪製路徑 (底層灰 + 上層藍)
              drawRoute(fullRouteCoords);
              
              // 更新UI
              const mins = Math.round(path.time/60000);
              const distKm = (path.distance/1000).toFixed(1);
              routeTime.innerText = mins + " 分鐘";
              routeDist.innerText = "(" + distKm + " 公里)";
              
              isRouteCalculated = true;
              
              // 判斷按鈕狀態
              const startInput = document.getElementById('start-input').value;
              if (startInput === "我的位置") {
                  mainBtn.innerText = isNavigating ? "繼續導航" : "開始導航";
                  mainBtn.className = "nav-mode";
              } else {
                  mainBtn.innerText = "查看列表";
                  mainBtn.className = "preview-mode";
              }
              
              // 若非導航重算中，縮放視野
              if (!isNavigating) {
                  const bounds = new maplibregl.LngLatBounds();
                  fullRouteCoords.forEach(c => bounds.extend(c));
                  map.fitBounds(bounds, { padding: 80 });
              } else {
                  // 如果是導航中重算，要更新導航邏輯的剩餘路徑
                  updateTurnInfo(currentRoutePath.instructions[0]);
              }
              
              renderRouteSteps();
          }
      } catch (e) { 
          alert("無法規劃路徑: " + e.message);
          exitNavigationMode(); // 出錯則退出導航
      } finally { 
          loadingIndicator.style.display = 'none'; 
          mainBtn.disabled = false;
          isRecalculating = false;
      }
  }

  // ==========================================
  // 繪圖與圖層管理
  // ==========================================
  function drawRoute(geoJsonCoords) {
      const sourceId = 'final-route-source';
      const bgLayerId = 'final-route-bg'; // 灰色完整路徑
      const fgLayerId = 'final-route-fg'; // 藍色剩餘路徑

      if (map.getLayer(fgLayerId)) map.removeLayer(fgLayerId);
      if (map.getLayer(bgLayerId)) map.removeLayer(bgLayerId);
      if (map.getSource(sourceId)) map.removeSource(sourceId);

      const cleanCoords = geoJsonCoords.map(c => [parseFloat(c[0]), parseFloat(c[1])]);

      map.addSource(sourceId, {
          type: 'geojson',
          data: { type: 'Feature', geometry: { type: 'LineString', coordinates: cleanCoords } }
      });

      // 1. 底層：灰色 (代表「總路徑」，走過的會露出來)
      map.addLayer({
          id: bgLayerId, type: 'line', source: sourceId,
          layout: { 'line-join': 'round', 'line-cap': 'round' },
          paint: { 'line-color': '#bdbdbd', 'line-width': 12, 'line-opacity': 0.8 }
      });

      // 2. 上層：藍色 (代表「剩餘路徑」，我們會動態更新它的數據)
      // 注意：這裡我們需要第二個 Source 來控制「剩餘路徑」，或者每次更新都 setData
      // 為了效能與邏輯簡單，我們建立另一個專門給「剩餘路徑」的 Source
  }

  // 更新藍色路徑 (剩餘路徑)
  function updateBlueRoute(remainingCoords) {
      const fgSourceId = 'active-route-source';
      const fgLayerId = 'active-route-fg';

      const data = { type: 'Feature', geometry: { type: 'LineString', coordinates: remainingCoords } };

      if (!map.getSource(fgSourceId)) {
          map.addSource(fgSourceId, { type: 'geojson', data: data });
          map.addLayer({
              id: fgLayerId, type: 'line', source: fgSourceId,
              layout: { 'line-join': 'round', 'line-cap': 'round' },
              paint: { 'line-color': '#4285F4', 'line-width': 12, 'line-opacity': 1.0 }
          });
      } else {
          map.getSource(fgSourceId).setData(data);
      }
  }

  function clearRouteLayers() {
      if (map.getLayer('active-route-fg')) map.removeLayer('active-route-fg');
      if (map.getSource('active-route-source')) map.removeSource('active-route-source');
      
      if (map.getLayer('final-route-bg')) map.removeLayer('final-route-bg');
      if (map.getSource('final-route-source')) map.removeSource('final-route-source');
  }

  // ==========================================
  // 導航模式 (核心邏輯升級)
  // ==========================================
  function enterNavigationMode() {
      if (!currentRoutePath || fullRouteCoords.length === 0) return;
      
      isNavigating = true;
      lastSpokenText = "";
      
      // UI 切換
      document.getElementById('search-panel').style.top = '-400px'; 
      navFooter.classList.remove('show');
      document.getElementById('turn-instruction').style.display = 'block';
      document.getElementById('btn-exit-nav').style.display = 'flex';
      closeStepsPanel();

      // 建立導航專用大標記 (如果還沒建立)
      if (!navMarker) {
          const el = document.createElement('div');
          el.className = 'nav-marker';
          el.innerHTML = '<div class="nav-arrow"></div>'; // 箭頭指示方向
          navMarker = new maplibregl.Marker({ element: el, rotationAlignment: 'map' })
              .setLngLat(startCoords)
              .addTo(map);
      } else {
          navMarker.addTo(map);
      }

      // 啟動追蹤
      navLocationHandler = (e) => {
          if (!isNavigating) return;
          const rawLat = e.coords.latitude;
          const rawLng = e.coords.longitude;
          const heading = e.coords.heading || map.getBearing();

          // 1. 計算吸附點 (Snapping)
          const snapResult = getNearestPointOnLine([rawLng, rawLat], fullRouteCoords);
          
          // 2. 判斷偏離 (Deviation)
          const deviationDist = snapResult.distance * 1000; // 轉公尺
          if (deviationDist > 40 && !isRecalculating) {
              // 偏離超過 40 公尺 -> 重新規劃
              console.log("偏離路徑，重新規劃...");
              speak("偏離路徑，重新規劃中");
              isRecalculating = true;
              startCoords = { lat: rawLat, lng: rawLng }; // 更新起點為當前位置
              calculateRoute(startCoords);
              return;
          }

          // 3. 使用吸附點作為顯示位置 (Visual Update)
          // 如果距離很近 (<20m) 就吸附，否則顯示真實位置但還沒觸發重算
          const displayCoords = (deviationDist < 20) ? snapResult.point : [rawLng, rawLat];
          
          navMarker.setLngLat(displayCoords);
          navMarker.setRotation(heading); // 旋轉箭頭

          // 相機跟隨
          map.easeTo({
              center: displayCoords,
              zoom: 19, pitch: 60, bearing: heading, 
              duration: 1000, easing: (t) => t
          });

          // 4. 更新藍色路徑 (變灰色效果)
          // 裁切掉 closestIndex 之前的點
          const remainingPath = fullRouteCoords.slice(snapResult.index);
          if (remainingPath.length > 1) {
              updateBlueRoute(remainingPath);
          }

          // 5. 更新導航指令 (Instruction Update)
          updateInstructionByProgress(snapResult.index);
      };

      // 監聽 GPS
      geolocateControl.on('geolocate', navLocationHandler);
      geolocateControl.trigger(); // 立即觸發一次

      // 初始化藍色路徑
      updateBlueRoute(fullRouteCoords);
      speak("開始導航");
  }

  function exitNavigationMode() {
      isNavigating = false;
      synth.cancel();
      
      if (navLocationHandler) {
          geolocateControl.off('geolocate', navLocationHandler);
          navLocationHandler = null;
      }
      
      if (navMarker) navMarker.remove(); // 移除大標記

      // 恢復 UI
      document.getElementById('search-panel').style.top = '16px';
      document.getElementById('turn-instruction').style.display = 'none';
      document.getElementById('btn-exit-nav').style.display = 'none';
      closeStepsPanel();
      navFooter.classList.add('show');
      
      map.easeTo({ pitch: 0, zoom: 16, bearing: 0 });
      
      // 恢復完整藍線顯示 (或重繪)
      if (fullRouteCoords.length > 0) drawRoute(fullRouteCoords);
      updateBlueRoute([]); // 清空動態層
  }

  // ==========================================
  // 數學運算：點到線的最短距離與投影點
  // ==========================================
  function getNearestPointOnLine(pt, lineCoords) {
      let minDist = Infinity;
      let nearestPoint = pt;
      let nearestIndex = 0;

      for (let i = 0; i < lineCoords.length - 1; i++) {
          const start = lineCoords[i];
          const end = lineCoords[i+1];
          const result = pDistance(pt[0], pt[1], start[0], start[1], end[0], end[1]);
          
          if (result.dist < minDist) {
              minDist = result.dist;
              nearestPoint = [result.x, result.y];
              nearestIndex = i;
          }
      }
      // 回傳：投影座標、線段索引、距離(km approx)
      // 注意：這裡的 dist 是經緯度單位的歐幾里得距離，需要轉公里
      // 簡單轉換：1度約 111km
      const distInKm = minDist * 111; 
      
      return { point: nearestPoint, index: nearestIndex, distance: distInKm };
  }

  // 計算點 (x,y) 到線段 (x1,y1)-(x2,y2) 的最短距離與投影點
  function pDistance(x, y, x1, y1, x2, y2) {
      var A = x - x1;
      var B = y - y1;
      var C = x2 - x1;
      var D = y2 - y1;

      var dot = A * C + B * D;
      var len_sq = C * C + D * D;
      var param = -1;
      if (len_sq != 0) // in case of 0 length line
          param = dot / len_sq;

      var xx, yy;

      if (param < 0) {
          xx = x1; yy = y1;
      } else if (param > 1) {
          xx = x2; yy = y2;
      } else {
          xx = x1 + param * C;
          yy = y1 + param * D;
      }

      var dx = x - xx;
      var dy = y - yy;
      return { x: xx, y: yy, dist: Math.sqrt(dx * dx + dy * dy) };
  }

  // ==========================================
  // 指令即時更新
  // ==========================================
  function updateInstructionByProgress(currentCoordIndex) {
      if (!currentRoutePath || !currentRoutePath.instructions) return;
      
      // GraphHopper instructions 有 interval: [start, end]
      // 找出包含目前 Index 的指令
      const instructions = currentRoutePath.instructions;
      let activeIns = null;
      let activeIdx = 0;

      for (let i = 0; i < instructions.length; i++) {
          const interval = instructions[i].interval;
          // interval 是一個陣列 [startIndex, endIndex]
          if (currentCoordIndex >= interval[0] && currentCoordIndex <= interval[1]) {
              activeIns = instructions[i];
              activeIdx = i;
              break;
          }
      }

      // 如果當前已經超過這個區間的後半段，可能可以預告下一個指令
      // 這裡簡單實作：顯示當前所在的指令，如果距離很近，顯示下一個
      if (activeIns) {
          // 計算剩餘距離 (從現在的 index 到 interval[1])
          // 這比較複雜，簡單做：直接顯示該指令的 text
          // 如果換了新指令，就更新 UI 和 語音
          if (document.getElementById('turn-text').innerText !== activeIns.text) {
              updateTurnInfo(activeIns);
          }
          
          // 也可以更新該指令剩餘的距離 (這需要重新累加 distance，這裡先顯示指令總長或靜態更新)
          // 為了精準距離，通常需要後端支持或前端複雜累加。這裡暫時保持顯示指令名稱。
      }
  }

  // ==========================================
  // 基礎交互邏輯
  // ==========================================
  function handleMainAction() {
      if (!isRouteCalculated) {
          calculateRoute();
      } else {
          const startInput = document.getElementById('start-input').value;
          if (startInput === "我的位置") {
              enterNavigationMode();
          } else {
              openStepsPanel();
              alert("起點非「我的位置」，僅提供路徑步驟預覽。");
          }
      }
  }

  function checkReadyState() {
      if (startCoords && endCoords) {
          navFooter.classList.add('show');
          if (!isRouteCalculated) {
              mainBtn.innerText = "規劃路徑";
              mainBtn.className = "plan-mode"; 
              routeTime.innerText = "準備中";
              routeDist.innerText = "請點擊規劃";
              mainBtn.disabled = false;
              clearRouteLayers();
              updateBlueRoute([]);
          }
      }
  }

  function togglePickMode(mode) {
      pickMode = (pickMode === mode) ? null : mode;
      const btnStart = document.getElementById('btn-pick-start');
      const btnEnd = document.getElementById('btn-pick-end');
      const canvas = map.getCanvas();

      btnStart.classList.remove('active');
      btnEnd.classList.remove('active');
      canvas.classList.remove('crosshair-cursor'); 

      if (pickMode === 'start') {
          btnStart.classList.add('active');
          map.getCanvas().style.cursor = 'crosshair';
          document.getElementById('start-input').placeholder = "請點擊地圖...";
      } else if (pickMode === 'end') {
          btnEnd.classList.add('active');
          map.getCanvas().style.cursor = 'crosshair';
          document.getElementById('end-input').placeholder = "請點擊地圖...";
      } else {
          map.getCanvas().style.cursor = '';
      }
  }

  // 強制更新定位並設為起點
  function forceUserLocation() {
      if (isNavigating) return;
      togglePickMode(null);
      geolocateControl.trigger();
      geolocateControl.once('geolocate', (e) => {
          const userCoords = { lng: e.coords.longitude, lat: e.coords.latitude };
          startCoords = userCoords;
          document.getElementById('start-input').value = "我的位置";
          if (startMarker) { startMarker.remove(); startMarker = null; }
          map.flyTo({ center: userCoords, zoom: 16, pitch: 0 });
          
          isRouteCalculated = false;
          checkReadyState();
      });
  }

  function setStartPoint(lngLat, name) {
      if (isNavigating) return;
      startCoords = lngLat;
      document.getElementById('start-input').value = name;
      document.getElementById('suggestions').style.display = 'none';
      if (startMarker) startMarker.remove();
      startMarker = new maplibregl.Marker({ color: '#1a73e8', draggable: true }).setLngLat(lngLat).addTo(map);
      
      startMarker.on('dragend', () => { 
          startCoords = startMarker.getLngLat(); 
          isRouteCalculated = false;
          checkReadyState();
      });
      
      map.flyTo({ center: lngLat, zoom: 16, pitch: 0 });
      isRouteCalculated = false;
      checkReadyState();
  }

  function setEndPoint(lngLat, name) {
      if (isNavigating) return;
      endCoords = lngLat;
      document.getElementById('end-input').value = name;
      document.getElementById('suggestions').style.display = 'none';
      
      if (endMarker) endMarker.remove();
      endMarker = new maplibregl.Marker({ color: '#d93025', draggable: true }).setLngLat(lngLat).addTo(map);
      
      endMarker.on('dragend', () => { 
          endCoords = endMarker.getLngLat(); 
          isRouteCalculated = false; 
          checkReadyState();
      });
      
      isRouteCalculated = false;
      checkReadyState();
  }

  let debounceTimer;
  function handleInput(type, val) {
      activeSearchType = type;
      if(pickMode) togglePickMode(null);
      clearTimeout(debounceTimer);
      if(!val) { document.getElementById('suggestions').style.display = 'none'; return; }
      debounceTimer = setTimeout(async () => {
          try {
              const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(val)}&limit=5&addressdetails=1&countrycodes=tw`);
              const data = await res.json();
              const container = document.getElementById('suggestions');
              container.innerHTML = '';
              if (data.length > 0) {
                  container.style.display = 'block';
                  data.forEach(item => {
                      const div = document.createElement('div');
                      div.className = 'suggestion-item';
                      const title = item.display_name.split(',')[0];
                      div.innerHTML = `<span class="s-title">${title}</span>`;
                      div.onclick = () => {
                          const coords = { lng: parseFloat(item.lon), lat: parseFloat(item.lat) };
                          if (activeSearchType === 'start') setStartPoint(coords, title);
                          else setEndPoint(coords, title);
                      };
                      container.appendChild(div);
                  });
              }
          } catch(e){}
      }, 500);
  }

  function renderRouteSteps() {
      const listContainer = document.getElementById('steps-list-container');
      listContainer.innerHTML = '';
      if (!currentRoutePath || !currentRoutePath.instructions) return;
      currentRoutePath.instructions.forEach(ins => {
          let icon = 'straight';
          if (ins.sign === -2 || ins.sign === -1) icon = 'turn_left';
          if (ins.sign === 2 || ins.sign === 1) icon = 'turn_right';
          if (ins.sign === 4) icon = 'flag';
          if (ins.sign === 0) icon = 'straight';
          if (ins.sign === 6) icon = 'roundabout_right';
          
          const li = document.createElement('li');
          li.className = 'step-item';
          li.innerHTML = `
            <span class="material-icons step-icon">${icon}</span>
            <div class="step-text">${ins.text}</div>
            <div class="step-dist">${formatDist(ins.distance)}</div>
          `;
          listContainer.appendChild(li);
      });
  }

  function formatDist(m) {
      if (m > 1000) return (m/1000).toFixed(1) + " km";
      return Math.round(m) + " m";
  }

  function openStepsPanel() {
      if(document.getElementById('steps-list-container').innerHTML === '') renderRouteSteps();
      stepsPanel.classList.add('open');
  }

  function closeStepsPanel() { 
      stepsPanel.classList.remove('open'); 
  }

  function updateTurnInfo(ins) {
      if (!ins) return;
      document.getElementById('turn-text').innerText = ins.text;
      document.getElementById('turn-dist').innerText = Math.round(ins.distance) + " 公尺";
      let icon = 'straight';
      if (ins.sign === -2 || ins.sign === -1) icon = 'turn_left';
      if (ins.sign === 2 || ins.sign === 1) icon = 'turn_right';
      if (ins.sign === 4) icon = 'flag';
      if (ins.sign === 6) icon = 'roundabout_right';
      document.getElementById('turn-icon').innerText = icon;
      speak(ins.text);
  }

  function toggleVoice() {
      isVoiceEnabled = !isVoiceEnabled;
      const icon = document.getElementById('voice-icon');
      icon.innerText = isVoiceEnabled ? 'volume_up' : 'volume_off';
      if(isVoiceEnabled) speak("語音開啟"); else synth.cancel();
  }

  function speak(text) {
      if (!isVoiceEnabled || !text || text === lastSpokenText) return;
      synth.cancel();
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = 'zh-TW';
      synth.speak(utterance);
      lastSpokenText = text;
  }

  function clearEnd() {
      document.getElementById('end-input').value = '';
      if(pickMode) togglePickMode(null);
      if (endMarker) endMarker.remove();
      endMarker = null; endCoords = null;
      
      clearRouteLayers();
      updateBlueRoute([]);

      navFooter.classList.remove('show');
      currentRoutePath = null;
      fullRouteCoords = [];
      isRouteCalculated = false;
  }

  initMap();
</script>
</body>
</html>
