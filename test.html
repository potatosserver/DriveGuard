<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="utf-8" />
  <title>3D 智能語音導航 (傾角鎖定 85 度版)</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />

  <!-- MapLibre GL JS -->
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

  <!-- Google Fonts & Icons -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <style>
    /* --- 全域設定 --- */
    body { margin: 0; padding: 0; font-family: 'Roboto', sans-serif; overflow: hidden; background: #eee; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; z-index: 1; }
    
    .crosshair-cursor .maplibregl-canvas { cursor: crosshair !important; }

    /* --- 搜尋面板 --- */
    #search-panel {
        position: absolute; top: 16px; left: 50%; transform: translateX(-50%);
        width: 92%; max-width: 420px; z-index: 100; 
        background: rgba(255, 255, 255, 0.98);
        border-radius: 12px; 
        box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        padding: 12px; 
        display: flex; flex-direction: column; gap: 8px; 
        transition: top 0.4s cubic-bezier(0.4, 0.0, 0.2, 1);
    }

    .input-row { display: flex; align-items: center; gap: 10px; }
    
    .input-box {
        flex: 1; display: flex; align-items: center; 
        background: #f1f3f4; border-radius: 8px; padding: 4px 12px;
        transition: background 0.2s, box-shadow 0.2s;
    }
    .input-box:focus-within { background: #fff; box-shadow: 0 0 0 2px #4285F4; }
    .input-box input { 
        border: none; background: transparent; flex: 1; padding: 10px 0; 
        font-size: 16px; outline: none; color: #202124; 
    }
    
    .icon-btn { 
        padding: 10px; border-radius: 50%; cursor: pointer; color: #5f6368; 
        transition: all 0.2s; display: flex; align-items: center; justify-content: center;
    }
    .icon-btn:hover { background: rgba(0,0,0,0.05); color: #202124; }
    .icon-btn.active { color: #1a73e8; background: #e8f0fe; }
    
    #suggestions { 
        max-height: 220px; overflow-y: auto; display: none; margin-top: 5px; 
        border-top: 1px solid #eee; 
    }
    .suggestion-item { 
        padding: 12px 8px; cursor: pointer; border-radius: 4px; 
        display: flex; flex-direction: column; 
    }
    .suggestion-item:hover { background: #f8f9fa; }
    .s-title { font-weight: 500; color: #202124; font-size: 15px; }

    /* --- 底部導航面板 --- */
    #nav-footer {
        position: absolute; bottom: 0; left: 0; width: 100%; 
        background: white; z-index: 1000;
        border-top-left-radius: 24px; border-top-right-radius: 24px;
        box-shadow: 0 -4px 20px rgba(0,0,0,0.15); 
        transform: translateY(110%); 
        transition: transform 0.4s cubic-bezier(0.2, 0, 0, 1); 
        padding: 20px 20px 30px 20px; box-sizing: border-box;
    }
    #nav-footer.show { transform: translateY(0); }

    .nav-info-container { display: flex; justify-content: space-between; align-items: center; }
    .route-meta h1 { margin: 0; font-size: 26px; color: #1a73e8; font-weight: 700; }
    .route-meta span { color: #5f6368; font-size: 16px; font-weight: 500; }

    /* 主要按鈕樣式 */
    #btn-main-action {
        background: #1a73e8; color: white; border: none; 
        padding: 14px 32px; border-radius: 30px; 
        font-size: 16px; font-weight: 600; cursor: pointer; 
        box-shadow: 0 4px 10px rgba(26, 115, 232, 0.3);
        transition: transform 0.1s, background 0.2s;
        min-width: 120px;
    }
    #btn-main-action:active { transform: scale(0.96); }
    #btn-main-action.plan-mode { background: #009688; }
    #btn-main-action.nav-mode { background: #1a73e8; }
    #btn-main-action.preview-mode { background: #5f6368; }

    /* --- 導航指令卡 --- */
    #turn-instruction {
        position: absolute; top: 16px; left: 50%; transform: translateX(-50%);
        width: 92%; max-width: 420px; 
        background: #263238; 
        color: white; 
        padding: 16px; border-radius: 12px; 
        z-index: 1001; display: none; 
        box-shadow: 0 8px 20px rgba(0,0,0,0.4);
    }
    
    .turn-body { display: flex; align-items: flex-start; justify-content: space-between; }
    .turn-left { display: flex; align-items: center; gap: 16px; }
    .turn-icon-large { font-size: 48px; color: #fff; }
    
    .turn-text-group { display: flex; flex-direction: column; }
    #turn-dist { font-size: 26px; font-weight: 700; color: #4fc3f7; line-height: 1.2; }
    #turn-text { font-size: 18px; font-weight: 400; opacity: 0.9; margin-top: 4px; }

    .turn-actions { display: flex; gap: 8px; }
    .glass-btn { 
        background: rgba(255,255,255,0.15); border: none; color: white;
        width: 44px; height: 44px; border-radius: 50%; 
        cursor: pointer; display: flex; align-items: center; justify-content: center;
        transition: background 0.2s;
    }
    .glass-btn:hover { background: rgba(255,255,255,0.25); }

    /* --- 退出按鈕 --- */
    #btn-exit-nav {
        position: absolute; bottom: 40px; right: 20px; 
        background: #fff; color: #d93025;
        width: 60px; height: 60px; border-radius: 50%; 
        border: none; display: none;
        z-index: 1002; cursor: pointer; 
        align-items: center; justify-content: center; 
        box-shadow: 0 6px 16px rgba(0,0,0,0.2);
        transition: transform 0.2s;
    }
    #btn-exit-nav:hover { transform: scale(1.05); }

    /* --- 步驟詳情面板 --- */
    #steps-panel {
        position: absolute; bottom: 0; left: 0; width: 100%; height: 60%; 
        background: white; z-index: 2000; 
        border-top-left-radius: 20px; border-top-right-radius: 20px;
        transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        display: flex; flex-direction: column; box-shadow: 0 -10px 40px rgba(0,0,0,0.2);
    }
    #steps-panel.open { transform: translateY(0); }
    
    .steps-header { 
        padding: 18px 20px; border-bottom: 1px solid #f1f3f4; 
        display: flex; justify-content: space-between; align-items: center; 
        font-weight: 700; font-size: 18px; color: #202124;
    }
    .steps-list { flex: 1; overflow-y: auto; padding: 0; margin: 0; list-style: none; }
    .step-item { 
        padding: 16px 20px; border-bottom: 1px solid #f8f9fa; 
        display: flex; gap: 16px; align-items: center; 
    }
    .step-icon { color: #5f6368; }
    .step-text { flex: 1; font-size: 16px; color: #3c4043; line-height: 1.5; }
    .step-dist { color: #1a73e8; font-weight: 500; font-size: 14px; min-width: 60px; text-align: right; }

    /* --- Loading --- */
    #loading-indicator {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.95); padding: 20px 30px;
      border-radius: 12px; z-index: 3000; display: none; 
      box-shadow: 0 8px 24px rgba(0,0,0,0.2);
      text-align: center;
    }
    .spinner {
        border: 4px solid #f3f3f3; border-top: 4px solid #1a73e8;
        border-radius: 50%; width: 30px; height: 30px;
        animation: spin 1s linear infinite; margin: 0 auto 10px auto;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .loading-text { font-weight: 500; color: #555; }

    /* --- 導航專用大標記 --- */
    .nav-marker {
        width: 32px; height: 32px;
        background: #4285F4;
        border: 3px solid white;
        border-radius: 50%;
        box-shadow: 0 0 0 10px rgba(66, 133, 244, 0.3);
        display: flex; align-items: center; justify-content: center;
    }
    .nav-arrow {
        width: 0; height: 0;
        border-left: 8px solid transparent;
        border-right: 8px solid transparent;
        border-bottom: 14px solid white;
        transform: translateY(-2px);
    }

    /* 隱藏原生地圖定位點 */
    body.nav-active .maplibregl-user-location-dot,
    body.nav-active .maplibregl-user-location-accuracy-circle {
        display: none !important;
        opacity: 0 !important;
    }

  </style>
</head>
<body class="crosshair-cursor-enabled">

<div id="map"></div>

<!-- 搜尋面板 -->
<div id="search-panel">
    <div class="input-row">
        <span class="material-icons" style="color:#1a73e8; font-size: 20px;">trip_origin</span>
        <div class="input-box">
            <input type="text" id="start-input" placeholder="起點 (預設我的位置)" oninput="handleInput('start', this.value)" />
        </div>
        <div class="icon-btn" id="btn-pick-start" onclick="togglePickMode('start')" title="地圖選點">
            <span class="material-icons">touch_app</span>
        </div>
        <div class="icon-btn" onclick="forceUserLocation()" title="GPS定位">
            <span class="material-icons">my_location</span>
        </div>
    </div>
    
    <div class="input-row" style="height: 10px;"></div>

    <div class="input-row">
        <span class="material-icons" style="color:#d93025; font-size: 20px;">place</span>
        <div class="input-box">
            <input type="text" id="end-input" placeholder="輸入目的地" oninput="handleInput('end', this.value)" />
        </div>
        <div class="icon-btn" id="btn-pick-end" onclick="togglePickMode('end')" title="地圖選點">
            <span class="material-icons">touch_app</span>
        </div>
        <div class="icon-btn" onclick="clearEnd()" title="清除">
            <span class="material-icons">close</span>
        </div>
    </div>
    
    <div id="suggestions"></div>
</div>

<!-- 底部導航面板 -->
<div id="nav-footer">
    <div class="nav-info-container">
        <div class="route-meta">
            <h1 id="route-time">準備中</h1>
            <span id="route-dist">請點擊規劃</span>
        </div>
        <button id="btn-main-action" onclick="handleMainAction()">規劃路徑</button>
    </div>
</div>

<!-- 導航指令卡 -->
<div id="turn-instruction">
    <div class="turn-body">
        <div class="turn-left">
            <span class="material-icons turn-icon-large" id="turn-icon">straight</span>
            <div class="turn-text-group">
                <div id="turn-dist">--</div>
                <div id="turn-text">--</div>
            </div>
        </div>
        <div class="turn-actions">
            <button class="glass-btn" onclick="openStepsPanel()" title="列表">
                <span class="material-icons">format_list_bulleted</span>
            </button>
            <button class="glass-btn" onclick="toggleVoice()" title="語音">
                <span class="material-icons" id="voice-icon">volume_up</span>
            </button>
        </div>
    </div>
</div>

<button id="btn-exit-nav" onclick="exitNavigationMode()">
    <span class="material-icons" style="font-size: 32px;">close</span>
</button>

<!-- 步驟詳情面板 -->
<div id="steps-panel">
    <div class="steps-header">
        <span>路徑詳情</span>
        <div class="icon-btn" onclick="closeStepsPanel()">
            <span class="material-icons">keyboard_arrow_down</span>
        </div>
    </div>
    <ul class="steps-list" id="steps-list-container"></ul>
</div>

<div id="loading-indicator">
    <div class="spinner"></div>
    <div class="loading-text" id="loading-text">路徑計算中...</div>
</div>

<script>
  const graphHopperKey = '7cb4eb19-e0f4-40a3-a5e0-f2c039366f32'; 
  const style3D = 'https://tiles.openfreemap.org/styles/liberty';

  let map, geolocateControl;
  let startCoords = null, endCoords = null;
  let startMarker = null, endMarker = null;
  let navMarker = null; 
  
  let currentRoutePath = null; 
  let fullRouteCoords = []; 
  let isNavigating = false;
  let navLocationHandler = null;
  let activeSearchType = 'end';
  let pickMode = null; 
  let isVoiceEnabled = true;
  let lastSpokenText = "";
  let isRouteCalculated = false;
  let isRecalculating = false;

  const synth = window.speechSynthesis;
  const loadingIndicator = document.getElementById('loading-indicator');
  const navFooter = document.getElementById('nav-footer');
  const stepsPanel = document.getElementById('steps-panel');
  const mainBtn = document.getElementById('btn-main-action');
  const routeTime = document.getElementById('route-time');
  const routeDist = document.getElementById('route-dist');

  let isUserInteracting = false; 
  let snapBackTimer = null;
  let lastNavCoords = null; 

  function initMap() {
    map = new maplibregl.Map({
      container: 'map',
      style: style3D,
      center: [121.5, 25.04],
      zoom: 15,
      pitch: 0,
      bearing: 0,
      antialias: true,
      maxPitch: 85 // 重要修正：允許地圖傾斜到 85 度
    });

    map.on('load', () => {
        geolocateControl = new maplibregl.GeolocateControl({
            positionOptions: { enableHighAccuracy: true },
            trackUserLocation: false, 
            showUserHeading: true
        });
        map.addControl(geolocateControl);
        
        forceUserLocation();

        geolocateControl.on('geolocate', (e) => {
            if (isNavigating) return;
            const userCoords = { lng: e.coords.longitude, lat: e.coords.latitude };
            const startInput = document.getElementById('start-input');
            if (startInput.value === "我的位置" || startInput.value === "") {
                startCoords = userCoords;
            }
        });

        map.on('click', (e) => {
            if (pickMode) {
                if (pickMode === 'start') setStartPoint(e.lngLat, "地圖已選點");
                else if (pickMode === 'end') setEndPoint(e.lngLat, "地圖已選點");
                togglePickMode(null);
            }
        });

        map.on('movestart', (e) => {
            if (isNavigating && e.originalEvent) {
                isUserInteracting = true;
                if (snapBackTimer) clearTimeout(snapBackTimer);
            }
        });

        map.on('moveend', (e) => {
            if (isNavigating && isUserInteracting) {
                if (snapBackTimer) clearTimeout(snapBackTimer);
                snapBackTimer = setTimeout(() => {
                    isUserInteracting = false;
                }, 5000);
            }
        });
    });
  }

  // ... (其餘路徑規劃與繪圖函式保持不變，包含之前修正的 findFirstSymbolLayer) ...
  function findFirstSymbolLayer() {
      const layers = map.getStyle().layers;
      for (const layer of layers) {
          if (layer.type === 'symbol') {
              return layer.id;
          }
      }
      return undefined;
  }

  async function calculateRoute(startLoc = startCoords) {
      if (!startLoc || !endCoords) return;
      if (isRecalculating) return;

      loadingIndicator.style.display = 'block';
      document.getElementById('loading-text').innerText = isNavigating ? "偏離路徑，重新規劃中..." : "路徑計算中...";
      mainBtn.disabled = true;

      clearRouteLayers();

      const params = new URLSearchParams();
      params.append('key', graphHopperKey);
      params.append('profile', 'car');
      params.append('locale', 'zh-TW');
      params.append('elevation', 'false');
      params.append('instructions', 'true');
      params.append('points_encoded', 'false'); 
      params.append('point', `${startLoc.lat},${startLoc.lng}`);
      params.append('point', `${endCoords.lat},${endCoords.lng}`);

      try {
          const res = await fetch(`https://graphhopper.com/api/1/route?${params.toString()}`);
          if (!res.ok) throw new Error("API Error");
          const data = await res.json();
          
          if (data.paths && data.paths.length > 0) {
              const path = data.paths[0];
              currentRoutePath = path;
              fullRouteCoords = path.points.coordinates;
              
              drawBaseRoute(fullRouteCoords);
              updateBlueRoute(fullRouteCoords);
              
              const mins = Math.round(path.time/60000);
              const distKm = (path.distance/1000).toFixed(1);
              routeTime.innerText = mins + " 分鐘";
              routeDist.innerText = "(" + distKm + " 公里)";
              
              isRouteCalculated = true;
              
              const startInput = document.getElementById('start-input').value;
              if (startInput === "我的位置") {
                  mainBtn.innerText = isNavigating ? "繼續導航" : "開始導航";
                  mainBtn.className = "nav-mode";
              } else {
                  mainBtn.innerText = "查看列表";
                  mainBtn.className = "preview-mode";
              }
              
              if (!isNavigating) {
                  const bounds = new maplibregl.LngLatBounds();
                  fullRouteCoords.forEach(c => bounds.extend(c));
                  map.fitBounds(bounds, { padding: 80 });
              } else {
                  if (currentRoutePath.instructions) {
                     updateTurnInfo(currentRoutePath.instructions[0], currentRoutePath.instructions[0].distance);
                  }
              }
              renderRouteSteps();
          }
      } catch (e) { 
          alert("無法規劃路徑: " + e.message);
          exitNavigationMode();
      } finally { 
          loadingIndicator.style.display = 'none'; 
          mainBtn.disabled = false;
          isRecalculating = false;
      }
  }

  function drawBaseRoute(geoJsonCoords) {
      const sourceId = 'final-route-bg-source';
      const layerId = 'final-route-bg-layer';

      if (map.getLayer(layerId)) map.removeLayer(layerId);
      if (map.getSource(sourceId)) map.removeSource(sourceId);

      map.addSource(sourceId, {
          type: 'geojson',
          data: { type: 'Feature', geometry: { type: 'LineString', coordinates: geoJsonCoords } }
      });

      const firstSymbolId = findFirstSymbolLayer();

      map.addLayer({
          id: layerId, type: 'line', source: sourceId,
          layout: { 'line-join': 'round', 'line-cap': 'round' },
          paint: { 
              'line-color': '#bdbdbd', 
              'line-width': 12, 
              'line-opacity': 0.8
          }
      }, firstSymbolId);
  }

  function updateBlueRoute(remainingCoords) {
      const fgSourceId = 'active-route-source';
      const fgLayerId = 'active-route-fg';
      const data = { type: 'Feature', geometry: { type: 'LineString', coordinates: remainingCoords } };

      if (map.getSource(fgSourceId)) {
          map.getSource(fgSourceId).setData(data);
      } else {
          map.addSource(fgSourceId, { type: 'geojson', data: data });
      }

      if (!map.getLayer(fgLayerId)) {
          const firstSymbolId = findFirstSymbolLayer();

          map.addLayer({
              id: fgLayerId, type: 'line', source: fgSourceId,
              layout: { 'line-join': 'round', 'line-cap': 'round' },
              paint: { 
                  'line-color': '#4285F4', 
                  'line-width': 12, 
                  'line-opacity': 1.0
              }
          }, firstSymbolId);
      }
  }

  function clearRouteLayers() {
      if (map.getLayer('active-route-fg')) map.removeLayer('active-route-fg');
      if (map.getSource('active-route-source')) map.removeSource('active-route-source');
      if (map.getLayer('final-route-bg-layer')) map.removeLayer('final-route-bg-layer');
      if (map.getSource('final-route-bg-source')) map.removeSource('final-route-bg-source');
  }

  // ==========================================
  // 導航模式 (核心修改處：鎖定 Pitch)
  // ==========================================
  function enterNavigationMode() {
      if (!currentRoutePath || fullRouteCoords.length === 0) return;
      
      isNavigating = true;
      lastSpokenText = "";
      isUserInteracting = false;
      lastNavCoords = null;
      
      document.body.classList.add('nav-active');

      document.getElementById('search-panel').style.top = '-400px'; 
      navFooter.classList.remove('show');
      document.getElementById('turn-instruction').style.display = 'block';
      document.getElementById('btn-exit-nav').style.display = 'flex';
      closeStepsPanel();

      // --- 鎖定傾角設定 ---
      // 先設定 Max 為 85 (確保可以轉到這麼斜)
      map.setMaxPitch(85);
      // 再設定 Min 為 85 (強制鎖定，使用者無法轉回來)
      map.setMinPitch(85);

      if (!navMarker) {
          const el = document.createElement('div');
          el.className = 'nav-marker';
          el.innerHTML = '<div class="nav-arrow"></div>'; 
          
          navMarker = new maplibregl.Marker({ 
              element: el, 
              rotationAlignment: 'map',
              pitchAlignment: 'map' 
          })
          .setLngLat(startCoords)
          .addTo(map);
      } else {
          navMarker.addTo(map);
      }

      const handleNavUpdate = (e) => {
          if (!isNavigating) return;
          const rawLat = e.coords.latitude;
          const rawLng = e.coords.longitude;
          const rawHeading = e.coords.heading;

          const snapResult = getNearestPointOnLine([rawLng, rawLat], fullRouteCoords);
          const deviationDist = snapResult.distance * 1000; 
          const RECALC_THRESHOLD = 50; 

          if (deviationDist > RECALC_THRESHOLD && !isRecalculating) {
              speak("偏離路徑，重新規劃中");
              isRecalculating = true;
              startCoords = { lat: rawLat, lng: rawLng };
              calculateRoute(startCoords);
              return;
          }

          const displayCoords = snapResult.point; 
          navMarker.setLngLat(displayCoords);
          
          let shouldUpdateBearing = false;
          let currentDist = 0;
          
          if (lastNavCoords) {
              const dLat = rawLat - lastNavCoords[1];
              const dLng = rawLng - lastNavCoords[0];
              const mLat = dLat * 111000;
              const mLng = dLng * 111000 * Math.cos(rawLat * Math.PI / 180);
              currentDist = Math.sqrt(mLat*mLat + mLng*mLng);
              
              if (currentDist > 2) shouldUpdateBearing = true;
          } else {
              shouldUpdateBearing = true;
          }

          let targetBearing = map.getBearing();
          if (shouldUpdateBearing && rawHeading !== null && !isNaN(rawHeading)) {
              navMarker.setRotation(rawHeading);
              targetBearing = rawHeading;
          }

          if (!isUserInteracting) {
              map.easeTo({
                  center: displayCoords,
                  zoom: 19, 
                  pitch: 85, // 導航時強制 85 度
                  bearing: targetBearing,
                  duration: 1000, 
                  easing: (t) => t
              });
          }

          if (shouldUpdateBearing) lastNavCoords = [rawLng, rawLat];

          const remainingPath = fullRouteCoords.slice(snapResult.index);
          if (remainingPath.length > 1) {
              updateBlueRoute(remainingPath);
          }

          updateInstructionByProgress(snapResult);
      };

      navLocationHandler = handleNavUpdate;
      geolocateControl.on('geolocate', navLocationHandler);
      geolocateControl.trigger();

      if (startCoords) {
          // 初始動畫也轉到 85 度
          map.easeTo({ center: startCoords, zoom: 19, pitch: 85, duration: 1500 });
      }

      speak("開始導航");
  }

  function exitNavigationMode() {
      isNavigating = false;
      isUserInteracting = false;
      document.body.classList.remove('nav-active');

      if(snapBackTimer) clearTimeout(snapBackTimer);
      synth.cancel();
      
      if (navLocationHandler) {
          geolocateControl.off('geolocate', navLocationHandler);
          navLocationHandler = null;
      }
      
      if (navMarker) navMarker.remove();

      document.getElementById('search-panel').style.top = '16px';
      document.getElementById('turn-instruction').style.display = 'none';
      document.getElementById('btn-exit-nav').style.display = 'none';
      closeStepsPanel();
      navFooter.classList.add('show');
      
      // 解除鎖定：恢復 minPitch 為 0，讓使用者可以看回俯視圖
      map.setMinPitch(0);
      map.setMaxPitch(85); 

      map.easeTo({ pitch: 0, zoom: 16, bearing: 0 });
      
      if (fullRouteCoords.length > 0) {
          updateBlueRoute(fullRouteCoords);
      }
  }

  // ... (其餘數學運算與輔助功能保持不變) ...
  function getNearestPointOnLine(pt, lineCoords) {
      let minDist = Infinity;
      let nearestPoint = pt;
      let nearestIndex = 0;
      const cosLat = Math.cos(pt[1] * Math.PI / 180);

      for (let i = 0; i < lineCoords.length - 1; i++) {
          const start = lineCoords[i];
          const end = lineCoords[i+1];
          const result = pDistance(
              pt[0] * cosLat, pt[1], 
              start[0] * cosLat, start[1], 
              end[0] * cosLat, end[1]
          );
          if (result.dist < minDist) {
              minDist = result.dist;
              nearestPoint = [result.x / cosLat, result.y];
              nearestIndex = i;
          }
      }
      const distInKm = minDist * 111; 
      return { point: nearestPoint, index: nearestIndex, distance: distInKm };
  }

  function pDistance(x, y, x1, y1, x2, y2) {
      var A = x - x1;
      var B = y - y1;
      var C = x2 - x1;
      var D = y2 - y1;
      var dot = A * C + B * D;
      var len_sq = C * C + D * D;
      var param = -1;
      if (len_sq != 0) param = dot / len_sq;
      var xx, yy;
      if (param < 0) { xx = x1; yy = y1; }
      else if (param > 1) { xx = x2; yy = y2; }
      else { xx = x1 + param * C; yy = y1 + param * D; }
      var dx = x - xx;
      var dy = y - yy;
      return { x: xx, y: yy, dist: Math.sqrt(dx * dx + dy * dy) };
  }
  
  function measureDist(p1, p2) {
      const cosLat = Math.cos(p1[1] * Math.PI / 180);
      const dx = (p2[0] - p1[0]) * cosLat;
      const dy = p2[1] - p1[1];
      return Math.sqrt(dx*dx + dy*dy) * 111000;
  }

  function getExactRemainingDistance(snappedPoint, currentIndex, instructionEndIndex, allCoords) {
      let totalDist = 0;
      if (currentIndex < allCoords.length - 1) {
          totalDist += measureDist(snappedPoint, allCoords[currentIndex + 1]);
      }
      for (let i = currentIndex + 1; i < instructionEndIndex; i++) {
          if (i < allCoords.length - 1) {
             totalDist += measureDist(allCoords[i], allCoords[i+1]);
          }
      }
      return totalDist;
  }

  function updateInstructionByProgress(snapResult) {
      if (!currentRoutePath || !currentRoutePath.instructions) return;
      const instructions = currentRoutePath.instructions;
      const currentCoordIndex = snapResult.index;
      const currentPoint = snapResult.point;

      let activeIns = null;
      for (let i = 0; i < instructions.length; i++) {
          const interval = instructions[i].interval;
          if (currentCoordIndex >= interval[0] && currentCoordIndex <= interval[1]) {
              activeIns = instructions[i];
              break;
          }
      }

      if (activeIns) {
          const remainingMeters = getExactRemainingDistance(currentPoint, currentCoordIndex, activeIns.interval[1], fullRouteCoords);
          updateTurnInfo(activeIns, remainingMeters);
      }
  }

  function formatDynamicDist(m) {
      if (m > 1000) return (m/1000).toFixed(1) + " 公里";
      if (m > 50) return (Math.round(m / 50) * 50) + " 公尺";
      return (Math.max(0, Math.round(m / 10) * 10)) + " 公尺";
  }

  function updateTurnInfo(ins, realDistance) {
      if (!ins) return;
      document.getElementById('turn-text').innerText = ins.text;
      
      const distToShow = (realDistance !== null && realDistance !== undefined) ? realDistance : ins.distance;
      document.getElementById('turn-dist').innerText = formatDynamicDist(distToShow);

      let icon = 'straight';
      if (ins.sign === -2 || ins.sign === -1) icon = 'turn_left';
      if (ins.sign === 2 || ins.sign === 1) icon = 'turn_right';
      if (ins.sign === 4) icon = 'flag';
      if (ins.sign === 6) icon = 'roundabout_right';
      document.getElementById('turn-icon').innerText = icon;
      
      if (document.getElementById('turn-text').innerText !== lastSpokenText) {
         speak(ins.text);
      }
  }

  function handleMainAction() {
      if (!isRouteCalculated) {
          calculateRoute();
      } else {
          const startInput = document.getElementById('start-input').value;
          if (startInput === "我的位置") {
              enterNavigationMode();
          } else {
              openStepsPanel();
              alert("起點非「我的位置」，僅提供路徑步驟預覽。");
          }
      }
  }

  function forceUserLocation() {
      if (isNavigating) return;
      togglePickMode(null);
      geolocateControl.trigger();
      geolocateControl.once('geolocate', (e) => {
          const userCoords = { lng: e.coords.longitude, lat: e.coords.latitude };
          startCoords = userCoords;
          document.getElementById('start-input').value = "我的位置";
          if (startMarker) { startMarker.remove(); startMarker = null; }
          map.flyTo({ center: userCoords, zoom: 16, pitch: 0 });
          isRouteCalculated = false;
          checkReadyState(); 
      });
  }

  function setStartPoint(lngLat, name) {
      if (isNavigating) return;
      startCoords = lngLat;
      document.getElementById('start-input').value = name;
      document.getElementById('suggestions').style.display = 'none';
      if (startMarker) startMarker.remove();
      startMarker = new maplibregl.Marker({ color: '#1a73e8', draggable: true }).setLngLat(lngLat).addTo(map);
      
      startMarker.on('dragend', () => { 
          startCoords = startMarker.getLngLat(); 
          isRouteCalculated = false;
          checkReadyState();
      });
      map.flyTo({ center: lngLat, zoom: 16, pitch: 0 });
      isRouteCalculated = false;
      checkReadyState();
  }

  function setEndPoint(lngLat, name) {
      if (isNavigating) return;
      endCoords = lngLat;
      document.getElementById('end-input').value = name;
      document.getElementById('suggestions').style.display = 'none';
      if (endMarker) endMarker.remove();
      endMarker = new maplibregl.Marker({ color: '#d93025', draggable: true }).setLngLat(lngLat).addTo(map);
      
      endMarker.on('dragend', () => { 
          endCoords = endMarker.getLngLat(); 
          isRouteCalculated = false; 
          checkReadyState();
      });
      isRouteCalculated = false;
      checkReadyState();
  }

  function checkReadyState() {
      if (startCoords && endCoords) {
          navFooter.classList.add('show');
          if (!isRouteCalculated) {
              mainBtn.innerText = "規劃路徑";
              mainBtn.className = "plan-mode"; 
              routeTime.innerText = "準備中";
              routeDist.innerText = "請點擊規劃";
              mainBtn.disabled = false;
              clearRouteLayers();
              updateBlueRoute([]);
          }
      }
  }

  let debounceTimer;
  function handleInput(type, val) {
      activeSearchType = type;
      if(pickMode) togglePickMode(null);
      clearTimeout(debounceTimer);
      if(!val) { document.getElementById('suggestions').style.display = 'none'; return; }
      debounceTimer = setTimeout(async () => {
          try {
              const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(val)}&limit=5&addressdetails=1&countrycodes=tw`);
              const data = await res.json();
              const container = document.getElementById('suggestions');
              container.innerHTML = '';
              if (data.length > 0) {
                  container.style.display = 'block';
                  data.forEach(item => {
                      const div = document.createElement('div');
                      div.className = 'suggestion-item';
                      const title = item.display_name.split(',')[0];
                      div.innerHTML = `<span class="s-title">${title}</span>`;
                      div.onclick = () => {
                          const coords = { lng: parseFloat(item.lon), lat: parseFloat(item.lat) };
                          if (activeSearchType === 'start') setStartPoint(coords, title);
                          else setEndPoint(coords, title);
                      };
                      container.appendChild(div);
                  });
              }
          } catch(e){}
      }, 500);
  }

  function renderRouteSteps() {
      const listContainer = document.getElementById('steps-list-container');
      listContainer.innerHTML = '';
      if (!currentRoutePath || !currentRoutePath.instructions) return;
      currentRoutePath.instructions.forEach(ins => {
          let icon = 'straight';
          if (ins.sign === -2 || ins.sign === -1) icon = 'turn_left';
          if (ins.sign === 2 || ins.sign === 1) icon = 'turn_right';
          if (ins.sign === 4) icon = 'flag';
          if (ins.sign === 0) icon = 'straight';
          if (ins.sign === 6) icon = 'roundabout_right';
          
          const li = document.createElement('li');
          li.className = 'step-item';
          li.innerHTML = `
            <span class="material-icons step-icon">${icon}</span>
            <div class="step-text">${ins.text}</div>
            <div class="step-dist">${formatDist(ins.distance)}</div>
          `;
          listContainer.appendChild(li);
      });
  }

  function formatDist(m) {
      if (m > 1000) return (m/1000).toFixed(1) + " km";
      return Math.round(m) + " m";
  }

  function openStepsPanel() {
      if(document.getElementById('steps-list-container').innerHTML === '') renderRouteSteps();
      stepsPanel.classList.add('open');
  }

  function closeStepsPanel() { stepsPanel.classList.remove('open'); }

  function toggleVoice() {
      isVoiceEnabled = !isVoiceEnabled;
      const icon = document.getElementById('voice-icon');
      icon.innerText = isVoiceEnabled ? 'volume_up' : 'volume_off';
      if(isVoiceEnabled) speak("語音開啟"); else synth.cancel();
  }

  function speak(text) {
      if (!isVoiceEnabled || !text || text === lastSpokenText) return;
      synth.cancel();
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = 'zh-TW';
      synth.speak(utterance);
      lastSpokenText = text;
  }

  function togglePickMode(mode) {
      pickMode = (pickMode === mode) ? null : mode;
      const btnStart = document.getElementById('btn-pick-start');
      const btnEnd = document.getElementById('btn-pick-end');
      const canvas = map.getCanvas();

      btnStart.classList.remove('active');
      btnEnd.classList.remove('active');
      canvas.classList.remove('crosshair-cursor'); 

      if (pickMode === 'start') {
          btnStart.classList.add('active');
          map.getCanvas().style.cursor = 'crosshair';
          document.getElementById('start-input').placeholder = "請點擊地圖...";
      } else if (pickMode === 'end') {
          btnEnd.classList.add('active');
          map.getCanvas().style.cursor = 'crosshair';
          document.getElementById('end-input').placeholder = "請點擊地圖...";
      } else {
          map.getCanvas().style.cursor = '';
      }
  }

  function clearEnd() {
      document.getElementById('end-input').value = '';
      if(pickMode) togglePickMode(null);
      if (endMarker) endMarker.remove();
      endMarker = null; endCoords = null;
      
      clearRouteLayers();
      updateBlueRoute([]);

      navFooter.classList.remove('show');
      currentRoutePath = null;
      fullRouteCoords = [];
      isRouteCalculated = false;
  }

  initMap();
</script>
</body>
</html>
