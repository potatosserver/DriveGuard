<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" />
    <title>智慧型測速警示時速表</title>
    <style>
        :root {
            /* 深色模式變數 */
            --bg-gradient-start-dark: #2b324d; --bg-gradient-end-dark: #1c2033;
            --text-color-dark: #e0e0e0; --clock-color-dark: #a9b7d9;
            --gauge-bg-dark: #2a3148; --gauge-border-dark: #1a1e2c;
            --gauge-inner-bg-start-dark: #2e3650; --gauge-inner-bg-end-dark: #22283e;
            --tick-color-dark: #56648a; --tick-major-color-dark: #a9b7d9;

            /* 日間模式變數 */
            --bg-gradient-start-light: #e9eef2; --bg-gradient-end-light: #f8f9fa;
            --text-color-light: #343a40; --clock-color-light: #5a6a7b;
            --gauge-bg-light: #dde4ea; --gauge-border-light: #c8d0d8;
            --gauge-inner-bg-start-light: #e2e8ed; --gauge-inner-bg-end-light: #f7f8f9;
            --tick-color-light: #90a0b1; --tick-major-color-light: #495057;
        }

        html, body { margin: 0; padding: 0; overflow: hidden; width: 100dvw; height: 100dvh; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; transition: background 0.5s, color 0.5s; }
        body[data-theme="dark"] { background: linear-gradient(135deg, var(--bg-gradient-start-dark), var(--bg-gradient-end-dark)); color: var(--text-color-dark); }
        body[data-theme="light"] { background: linear-gradient(135deg, var(--bg-gradient-start-light), var(--bg-gradient-end-light)); color: var(--text-color-light); }
        .container { display: flex; width: 100%; height: 100%; justify-content: center; align-items: center; padding: 20px; box-sizing: border-box; }
        .left-panel { flex: 1; display: flex; justify-content: center; align-items: center; }
        .speedometer-container { flex: 1; display: flex; justify-content: center; align-items: center; }
        .speedometer-wrapper {
            flex-grow: 0;
            flex-shrink: 0;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            aspect-ratio: 1 / 1;
            height: 85vmin;
            max-width: 400px;
            max-height: 400px;
        }
        #clock { font-size: 8vmin; font-weight: 500; transition: color 0.5s; }
        body[data-theme="dark"] #clock { color: var(--clock-color-dark); text-shadow: 0 0 10px rgba(169, 183, 217, 0.5); }
        body[data-theme="light"] #clock { color: var(--clock-color-light); text-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        
        @media (orientation: portrait) {
            body { transform-origin: center center; width: 100dvh; height: 100dvw; transform: rotate(90deg); position: absolute; top: 50%; left: 50%; margin-top: -50dvw; margin-left: -50dvh; }
        }

        .info-stack { 
            position: relative;
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
        }

        #unified-alert { 
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 20px; 
            background-color: rgba(43, 50, 77, 0.85); /* Default camera color */
            color: white; 
            padding: 10px 15px; 
            border-radius: 12px; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.5); 
            border: 1px solid rgba(255,255,255,0.2); 
            text-align: center; 
            z-index: 100; 
            display: none; 
            font-weight: 500; 
            animation: fadeIn 0.5s ease-in-out; 
            min-width: 200px;
            transition: background-color 0.3s, border-color 0.3s;
        }
        body[data-theme="light"] #unified-alert { 
            background-color: rgba(255, 255, 255, 0.85); 
            color: var(--text-color-light); 
            border-color: rgba(0,0,0,0.1); 
        }

        #unified-alert.alert-error {
            background-color: #d32f2f;
            border-color: rgba(255,255,255,0.4);
            color: white;
        }
        body[data-theme="light"] #unified-alert.alert-error { background-color: #dc3545; }

        #unified-alert.alert-success {
            background-color: #28a745;
            border-color: rgba(255,255,255,0.4);
            color: white;
        }
        body[data-theme="light"] #unified-alert.alert-success { background-color: #218838; }

        #alert-title { margin: 0 0 8px 0; font-size: 1em; }
        #alert-body { display: flex; flex-direction: column; align-items: center; font-size: 0.9em; }
        
        .speed-limit-sign { 
            position: absolute;
            bottom: 100%;
            left: 50%;
            margin-bottom: 20px;
            width: 80px; height: 80px; background-color: white; border: 7px solid #dc3545; border-radius: 50%; color: #343a40; 
            display: flex; justify-content: center; align-items: center; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; font-weight: 700; font-size: 36px; 
            z-index: 200; box-shadow: 0 4px 15px rgba(0,0,0,0.3); 
            transform: translateX(-50%) scale(0); 
            transition: transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28); 
        }
        .speed-limit-sign.visible { transform: translateX(-50%) scale(1); }
        
        .gauge { position: absolute; width: 100%; height: 100%; border-radius: 50%; display: flex; justify-content: center; align-items: center; transition: background 0.5s, border-color 0.5s; }
        body[data-theme="dark"] .gauge { background: var(--gauge-bg-dark); box-shadow: inset 0 0 25px rgba(0, 0, 0, 0.5), 0 0 15px rgba(0, 0, 0, 0.3); border: 5px solid var(--gauge-border-dark); }
        body[data-theme="light"] .gauge { background: var(--gauge-bg-light); box-shadow: inset 0 0 15px rgba(0,0,0,0.1), 0 5px 10px rgba(0,0,0,0.1); border: 5px solid var(--gauge-border-light); }
        .gauge-inner { position: relative; width: 80%; height: 80%; border-radius: 50%; box-shadow: 0 0 25px rgba(0,0,0,0.4); z-index: 1; transition: background 0.5s; }
        body[data-theme="dark"] .gauge-inner { background: linear-gradient(145deg, var(--gauge-inner-bg-start-dark), var(--gauge-inner-bg-end-dark)); }
        body[data-theme="light"] .gauge-inner { background: linear-gradient(145deg, var(--gauge-inner-bg-start-light), var(--gauge-inner-bg-end-light)); }
        .needle { position: absolute; width: 4px; height: 30%; background: linear-gradient(to top, #ff4500, #ff8c00); border-radius: 2px; bottom: 50%; left: calc(50% - 2px); transform-origin: bottom center; transform: rotate(-135deg); transition: transform 0.5s cubic-bezier(0.4, 0.0, 0.2, 1); box-shadow: 0 0 10px rgba(255, 69, 0, 0.7); z-index: 10; }
        
        .needle::after { content: ''; position: absolute; width: 15px; height: 15px; border-radius: 50%; border-width: 3px; border-style: solid; bottom: -10.5px; left: -8.5px; }
        body[data-theme="dark"] .needle::after { background: #e0e0e0; border-color: #1c2033; }
        body[data-theme="light"] .needle::after { background: #f8f9fa; border-color: #495057; }
        
        .digital-speed { position: absolute; bottom: 15%; z-index: 5; transition: color 0.5s, text-shadow 0.5s; width: 100%; display: flex; flex-direction: column; align-items: center; text-align: center; }
        body[data-theme="dark"] .digital-speed { color: #00d1ff; text-shadow: 0 0 15px rgba(0, 209, 255, 0.8); }
        body[data-theme="light"] .digital-speed { color: #007bff; text-shadow: none; }
        #speed-value { font-size: 5em; font-weight: 700; letter-spacing: 2px; transition: color 0.2s; line-height: 1; }
        #speed-unit { font-size: 1.3em; font-weight: 300; opacity: 0.8; }

        .overspeed { color: #dc3545 !important; animation: flashing 1s infinite; }
        @keyframes flashing { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
        .tick { position: absolute; width: 2px; transform: translate(-50%, -50%); transition: background-color 0.5s; }
        .tick.major { height: 15px; } .tick.minor { height: 10px; }
        body[data-theme="dark"] .tick { background-color: var(--tick-color-dark); }
        body[data-theme="dark"] .tick.major { background-color: var(--tick-major-color-dark); }
        body[data-theme="light"] .tick { background-color: var(--tick-color-light); }
        body[data-theme="light"] .tick.major { background-color: var(--tick-major-color-light); }
        .tick-number { position: absolute; font-size: 16px; font-weight: 500; transform: translate(-50%, -50%); z-index: 2; transition: color 0.5s; }
        body[data-theme="dark"] .tick-number { color: var(--tick-major-color-dark); }
        body[data-theme="light"] .tick-number { color: var(--tick-major-color-light); }
        
        #settings-btn { 
            position: fixed; top: 20px; right: 20px; 
            z-index: 201; cursor: pointer; 
            font-size: 28px; 
            opacity: 1;
            transition: transform 0.3s;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }
        body[data-theme="dark"] #settings-btn { color: var(--text-color-dark); }
        body[data-theme="light"] #settings-btn { 
            color: var(--text-color-light); 
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        #settings-btn:hover { transform: scale(1.1) rotate(20deg); }
        
        #settings-modal { 
            display: none; position: fixed; top: 0; left: 0; 
            width: 100%; height: 100%; background: rgba(0,0,0,0.6); 
            z-index: 300; justify-content: center; align-items: center;
            padding: 20px 0; box-sizing: border-box;
        }
        
        .settings-content {
            background: #2c3347; color: #f8f9fa; border-radius: 15px; 
            width: 90%; max-width: 340px; box-shadow: 0 5px 25px rgba(0,0,0,0.5);
            max-height: 100%; display: flex; flex-direction: column; overflow: hidden;
        }
        
        .settings-header {
            position: relative; display: flex; justify-content: center; align-items: center;
            padding: 20px 25px 15px; flex-shrink: 0; border-bottom: 1px solid #4a526d;
        }
        .settings-header h2 { margin: 0; }
        
        #close-settings {
            position: absolute; top: 50%; right: 20px;
            transform: translateY(-50%); font-size: 28px; cursor: pointer;
            color: #a9b7d9; transition: color 0.2s;
        }
        #close-settings:hover { color: #fff; }
        
        .settings-scroll-area {
            flex-grow: 1; overflow-y: auto; padding: 10px 25px 20px;
        }

        .setting-group-title { margin-top: 20px; margin-bottom: 10px; font-size: 0.9em; font-weight: 600; color: #a9b7d9; border-bottom: 1px solid #4a526d; padding-bottom: 8px;}
        .setting-item { margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center; }
        .setting-item label { font-weight: 500; }
        .toggle-switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; transition: .4s; border-radius: 28px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #007bff; }
        input:checked + .slider:before { transform: translateX(22px); }
        
        .setting-group.disabled,
        #distance-setting-container.disabled,
        #sound-toggle-container.disabled { 
            opacity: 0.5; pointer-events: none; 
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
    </style>
</head>
<body data-theme="dark">
    <div id="settings-btn"><span class="material-symbols-outlined">settings</span></div>
    <div class="container">
        <div class="left-panel">
            <div class="info-stack">
                <div id="speed-limit-sign" class="speed-limit-sign"></div>
                <div id="clock">00:00</div>
                <div id="unified-alert">
                    <h3 id="alert-title"></h3>
                    <div id="alert-body"></div>
                </div>
            </div>
        </div>
        <div class="speedometer-container">
            <div class="speedometer-wrapper">
                <div class="gauge"></div>
                <div class="gauge-inner"></div>
                <div class="needle" id="needle"></div>
                <div class="digital-speed"><span id="speed-value">0</span><span id="speed-unit">km/h</span></div>
            </div>
        </div>
    </div>
    
    <div id="settings-modal">
        <div class="settings-content">
            <div class="settings-header">
                <h2 data-i18n-key="settingsTitle">設定</h2>
                <span id="close-settings" class="material-symbols-outlined">close</span>
            </div>
            
            <div class="settings-scroll-area">
                <div class="setting-group-title" data-i18n-key="alertsGroupTitle">警示功能</div>
                <div class="setting-item">
                    <label data-i18n-key="cameraAlertLabel">測速照相警示</label>
                    <label class="toggle-switch"> <input type="checkbox" id="alerts-enabled-toggle"> <span class="slider"></span> </label>
                </div>

                <div class="setting-group" id="alert-settings-group">
                    <div class="setting-item" id="sound-toggle-container">
                        <label data-i18n-key="voiceAlertLabel">語音播報</label>
                        <label class="toggle-switch"> <input type="checkbox" id="sound-toggle"> <span class="slider"></span> </label>
                    </div>
                    <hr style="border-color: rgba(255,255,255,0.1); margin: 15px 0;">
                    <div class="setting-item">
                        <label data-i18n-key="smartDistanceLabel">智慧警示距離</label>
                        <label class="toggle-switch"> <input type="checkbox" id="smart-distance-toggle"> <span class="slider"></span> </label>
                    </div>
                    <div id="distance-setting-container">
                        <label data-i18n-key="manualDistanceLabel" style="display: block; margin-bottom: 10px; opacity: 0.8;">手動警示距離</label>
                        <div style="display:flex; justify-content: space-around;">
                            <input type="radio" id="dist300" name="distance" value="300"><label for="dist300"> 300m</label>
                            <input type="radio" id="dist500" name="distance" value="500"><label for="dist500"> 500m</label>
                            <input type="radio" id="dist1000" name="distance" value="1000"><label for="dist1000"> 1km</label>
                        </div>
                    </div>
                </div>

                <div class="setting-group-title" data-i18n-key="dataGroupTitle">資料管理</div>
                <div id="last-updated-info" style="font-size: 0.8em; opacity: 0.7; text-align: center; margin-bottom: 10px;"></div>
                <button id="manual-update-btn" data-i18n-key="manualUpdateBtn" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #007bff; background: transparent; color: #007bff; font-size: 0.9em; cursor: pointer; transition: background 0.2s, color 0.2s;">手動更新測速點資料</button>
                
                <div class="setting-group-title" data-i18n-key="appearanceGroupTitle">外觀</div>
                <div class="setting-item">
                    <label data-i18n-key="themeLabel">日間模式</label>
                    <label class="toggle-switch"> <input type="checkbox" id="theme-toggle"> <span class="slider"></span> </label>
                </div>
                 <!-- --- NEW (Language): Language toggle switch --- -->
                <div class="setting-item">
                    <label data-i18n-key="languageLabel">English Mode</label>
                    <label class="toggle-switch"> <input type="checkbox" id="language-toggle"> <span class="slider"></span> </label>
                </div>
            </div>
        </div>
    </div>

    <script>
        window.onload = function() {
            // --- DOM Element Declarations ---
            const clockElement = document.getElementById('clock');
            const speedValueElement = document.getElementById('speed-value');
            const needleElement = document.getElementById('needle');
            const gaugeElement = document.querySelector('.gauge');
            const unifiedAlertElement = document.getElementById('unified-alert');
            const alertTitleElement = document.getElementById('alert-title');
            const alertBodyElement = document.getElementById('alert-body');
            const settingsBtn = document.getElementById('settings-btn');
            const settingsModal = document.getElementById('settings-modal');
            const closeSettingsBtn = document.getElementById('close-settings');
            const distanceRadios = document.querySelectorAll('input[name="distance"]');
            const soundToggle = document.getElementById('sound-toggle');
            const themeToggle = document.getElementById('theme-toggle');
            const speedLimitSignElement = document.getElementById('speed-limit-sign');
            const alertsEnabledToggle = document.getElementById('alerts-enabled-toggle');
            const smartDistanceToggle = document.getElementById('smart-distance-toggle');
            const distanceSettingContainer = document.getElementById('distance-setting-container');
            const alertSettingsGroup = document.getElementById('alert-settings-group');
            const manualUpdateBtn = document.getElementById('manual-update-btn');
            const lastUpdatedInfo = document.getElementById('last-updated-info');
            const soundToggleContainer = document.getElementById('sound-toggle-container');
            const languageToggle = document.getElementById('language-toggle'); // New language toggle

            // --- Constants ---
            const MAX_SPEED = 200, START_ANGLE = -135, END_ANGLE = 135, ANGLE_RANGE = END_ANGLE - START_ANGLE;
            const CACHE_DURATION_MS = 24 * 60 * 60 * 1000;
            const MAX_HISTORY_POINTS = 5; 
            const CONFIRMATION_THRESHOLD = 2; 

            // --- NEW (Language): Centralized translation object ---
            const translations = {
                'zh-Hant': {
                    // Settings UI
                    settingsTitle: '設定',
                    alertsGroupTitle: '警示功能',
                    cameraAlertLabel: '測速照相警示',
                    voiceAlertLabel: '語音播報',
                    smartDistanceLabel: '智慧警示距離',
                    manualDistanceLabel: '手動警示距離',
                    dataGroupTitle: '資料管理',
                    manualUpdateBtn: '手動更新測速點資料',
                    manualUpdateBtnProgress: '更新中...',
                    appearanceGroupTitle: '外觀',
                    themeLabel: '日間模式',
                    languageLabel: '英文模式',
                    // Main UI & Alerts
                    alertTitle: '前方有測速照相',
                    alertDistance: '距離',
                    alertSpeedLimit: '速限',
                    lastUpdatePrefix: '上次更新',
                    lastUpdateNone: '尚無本地資料',
                    am: '上午',
                    pm: '下午',
                    // Custom Alerts
                    updateSuccessTitle: '更新成功',
                    updateSuccessBody: (count) => `已下載 ${count} 筆最新資料。`,
                    updateFailTitle: '更新失敗',
                    updateFailBody: '無法取得最新資料，將繼續使用舊有資料。',
                    downloadFailTitle: '資料下載失敗',
                    downloadFailBody: '無法取得測速照相資料。請檢查網路連線。',
                    // Units
                    kmUnit: '公里',
                    mUnit: '公尺',
                    // TTS
                    ttsIntro: (limit) => `前方有測速照相，限速 ${limit} 公里`,
                    ttsOverspeed: '，已超速',
                    ttsPassed: '通過',
                },
                'en': {
                    // Settings UI
                    settingsTitle: 'Settings',
                    alertsGroupTitle: 'Alerts',
                    cameraAlertLabel: 'Speed Camera Alerts',
                    voiceAlertLabel: 'Voice Announcements',
                    smartDistanceLabel: 'Smart Alert Distance',
                    manualDistanceLabel: 'Manual Alert Distance',
                    dataGroupTitle: 'Data Management',
                    manualUpdateBtn: 'Update Camera Data Manually',
                    manualUpdateBtnProgress: 'Updating...',
                    appearanceGroupTitle: 'Appearance',
                    themeLabel: 'Day Mode',
                    languageLabel: 'English Mode',
                    // Main UI & Alerts
                    alertTitle: 'Speed Camera Ahead',
                    alertDistance: 'Distance',
                    alertSpeedLimit: 'Speed Limit',
                    lastUpdatePrefix: 'Last Update',
                    lastUpdateNone: 'No local data available',
                    am: 'AM',
                    pm: 'PM',
                    // Custom Alerts
                    updateSuccessTitle: 'Update Successful',
                    updateSuccessBody: (count) => `Downloaded ${count} new records.`,
                    updateFailTitle: 'Update Failed',
                    updateFailBody: 'Could not fetch latest data. Using cached data.',
                    downloadFailTitle: 'Data Download Failed',
                    downloadFailBody: 'Could not fetch speed camera data. Please check your connection.',
                    // Units
                    kmUnit: 'km',
                    mUnit: 'm',
                    // TTS
                    ttsIntro: (limit) => `Speed camera ahead. Speed limit is ${limit} kilometers per hour.`,
                    ttsOverspeed: ', you are overspeeding.',
                    ttsPassed: 'Passed.',
                }
            };

            // --- State and Data Variables ---
            let cameraData = [];
            let currentAlertLimit = null;
            let isAlertingForCameraId = null;
            // --- MODIFIED (Language): Added language to settings ---
            let settings = { alertDistance: 500, soundEnabled: true, theme: 'dark', alertsEnabled: true, smartDistanceEnabled: false, language: 'zh-Hant' };
            let hasInteracted = false;
            let lastKnownSpeed = 0;
            let customAlertTimer = null;
            let isCameraAlertActive = false;
            let lastCameraInfo = { distance: 0, limit: 0 };
            let isPermissionErrorActive = false;
            let positionHistory = []; 
            let lastBearingToCamera = null;
            let alertCandidate = { cameraId: null, confirmCount: 0 }; 
            let lastDistanceToAlertingCamera = Infinity; 
            let speechQueue = [];
            let isSpeaking = false;
            let announcedDistances = new Set();

            document.body.addEventListener('click', () => { hasInteracted = true; }, { once: true });

            function initializeUI() {
                console.log("UI Initializing...");
                loadSettings();
                updateLanguageUI(); // Set initial language
                updateClock();
                setInterval(updateClock, 1000);
                requestAnimationFrame(() => {
                    createTicks();
                    window.addEventListener('resize', createTicks);
                });
                setupEventListeners();
                displayLastUpdateTime();
                console.log("UI Initialized.");
            }

            async function startBackgroundServices() {
                // ... (rest of the function is unchanged)
                console.log("Background services starting...");
                await loadCameraData();
                displayLastUpdateTime();

                if (navigator.geolocation) {
                    navigator.geolocation.watchPosition(handlePositionUpdate, handleError, {
                        enableHighAccuracy: true, maximumAge: 0, timeout: 5000
                    });
                     console.log("Geolocation watch position started.");
                } else {
                    showCustomAlert('定位錯誤', '您的瀏覽器不支援定位功能。', 'error', 0); // This alert is not translated as it's a very basic fallback
                }
            }

            async function fetchAndCacheCameraData() {
                // ... (function is largely unchanged, just error messages might need translation if shown to user)
                const apiUrl = 'https://cors-anywhere.potatosserver.workers.dev/?url=https://od.moi.gov.tw/api/v1/rest/datastore/A01010000C-000674-011';
                try {
                    const response = await fetch(apiUrl);
                    if (!response.ok) throw new Error(`HTTP 狀態: ${response.status}`);
                    
                    const data = await response.json();
                    const freshData = data.result.records.slice(1)
                        .map((cam, index) => ({ id: index, lat: parseFloat(cam.Latitude), lon: parseFloat(cam.Longitude), limit: parseInt(cam.limit, 10) }))
                        .filter(cam => !isNaN(cam.lat) && !isNaN(cam.lon) && !isNaN(cam.limit));
                    
                    cameraData = freshData;
                    localStorage.setItem('cameraData', JSON.stringify(cameraData));
                    localStorage.setItem('cameraDataTimestamp', Date.now().toString());
                    console.log(`新資料下載完成 (${cameraData.length} 筆) 並已存入快取`);
                    return true;
                } catch (error) {
                    console.error("資料下載失敗:", error);
                    const t = translations[settings.language];
                    showCustomAlert(t.downloadFailTitle, t.downloadFailBody, 'error', 8000);
                    return false;
                }
            }
            
            async function loadCameraData() {
                // ... (function is largely unchanged, just error messages might need translation if shown to user)
                let cachedData, cachedTimestamp;
                try {
                    cachedData = JSON.parse(localStorage.getItem('cameraData'));
                    cachedTimestamp = parseInt(localStorage.getItem('cameraDataTimestamp'), 10);
                } catch (e) { console.error("讀取快取失敗:", e); }

                if (cachedData && cachedTimestamp && (Date.now() - cachedTimestamp < CACHE_DURATION_MS)) {
                    cameraData = cachedData;
                    console.log(`資料從本地快取載入 (${cameraData.length} 筆)`);
                } else {
                    console.log("本地快取過期或不存在，正在從網路下載...");
                    const success = await fetchAndCacheCameraData();
                    if (!success && cachedData) {
                        cameraData = cachedData;
                        const t = translations[settings.language];
                        showCustomAlert(t.updateFailTitle, t.updateFailBody, 'error', 6000);
                    }
                }
            }

            async function handleManualUpdate() {
                const t = translations[settings.language];
                manualUpdateBtn.disabled = true;
                manualUpdateBtn.textContent = t.manualUpdateBtnProgress;
                const success = await fetchAndCacheCameraData();
                if (success) {
                    showCustomAlert(t.updateSuccessTitle, t.updateSuccessBody(cameraData.length), 'success', 5000);
                    displayLastUpdateTime();
                }
                manualUpdateBtn.disabled = false;
                manualUpdateBtn.textContent = t.manualUpdateBtn;
            }
            
            function displayLastUpdateTime() {
                const t = translations[settings.language];
                const timestamp = parseInt(localStorage.getItem('cameraDataTimestamp'), 10);
                lastUpdatedInfo.textContent = timestamp ? `${t.lastUpdatePrefix}: ${new Date(timestamp).toLocaleString()}` : t.lastUpdateNone;
            }

            // --- NEW (Language): Function to update all UI text elements ---
            function updateLanguageUI() {
                const lang = settings.language;
                const t = translations[lang];
                document.querySelectorAll('[data-i18n-key]').forEach(el => {
                    const key = el.dataset.i18nKey;
                    if (t[key]) {
                        el.textContent = t[key];
                    }
                });
                 // Also update dynamic elements that don't have the data attribute
                displayLastUpdateTime();
                updateClock();
            }

            function loadSettings() {
                const savedSettings = JSON.parse(localStorage.getItem('speedometerSettings'));
                if (savedSettings) settings = { ...settings, ...savedSettings };
                
                document.querySelector(`input[name="distance"][value="${settings.alertDistance}"]`).checked = true;
                soundToggle.checked = settings.soundEnabled;
                alertsEnabledToggle.checked = settings.alertsEnabled;
                smartDistanceToggle.checked = settings.smartDistanceEnabled;
                themeToggle.checked = settings.theme === 'light';
                languageToggle.checked = settings.language === 'en'; // Set toggle based on language
                
                document.body.setAttribute('data-theme', settings.theme);
                updateSettingsUI();
            }

            function saveSettings() { localStorage.setItem('speedometerSettings', JSON.stringify(settings)); }
            
            function updateSettingsUI() {
                alertSettingsGroup.classList.toggle('disabled', !settings.alertsEnabled);
                if (settings.alertsEnabled) {
                    distanceSettingContainer.classList.toggle('disabled', settings.smartDistanceEnabled);
                    soundToggleContainer.classList.toggle('disabled', !settings.alertsEnabled);
                }
            }

            function setupEventListeners() {
                settingsBtn.addEventListener('click', () => settingsModal.style.display = 'flex');
                closeSettingsBtn.addEventListener('click', () => settingsModal.style.display = 'none');
                manualUpdateBtn.addEventListener('click', handleManualUpdate);
                
                languageToggle.addEventListener('change', (e) => {
                    settings.language = e.target.checked ? 'en' : 'zh-Hant';
                    updateLanguageUI();
                    saveSettings();
                    // If an alert is active, update its text
                    if (isCameraAlertActive) {
                       showAlert(lastCameraInfo.distance, lastCameraInfo.limit);
                    }
                });
                
                alertsEnabledToggle.addEventListener('change', (e) => {
                    settings.alertsEnabled = e.target.checked;
                    if (!settings.alertsEnabled) {
                        hideAlert();
                         if ('speechSynthesis' in window) speechSynthesis.cancel();
                    }
                    updateSettingsUI(); saveSettings();
                });
                smartDistanceToggle.addEventListener('change', (e) => {
                    settings.smartDistanceEnabled = e.target.checked;
                    updateSettingsUI(); saveSettings();
                });
                distanceRadios.forEach(radio => radio.addEventListener('change', (e) => {
                    settings.alertDistance = parseInt(e.target.value, 10);
                    saveSettings();
                }));
                soundToggle.addEventListener('change', (e) => { settings.soundEnabled = e.target.checked; saveSettings(); });
                themeToggle.addEventListener('change', (e) => {
                    settings.theme = e.target.checked ? 'light' : 'dark';
                    document.body.setAttribute('data-theme', settings.theme);
                    saveSettings();
                });
            }
            
            function updateSpeed(position) { 
                // ... (function is unchanged)
                let speedInMps = position.coords.speed; if (speedInMps !== null && speedInMps >= 0) { let speedInKph = speedInMps * 3.6; lastKnownSpeed = speedInKph; const displaySpeed = Math.min(speedInKph, MAX_SPEED); speedValueElement.textContent = Math.round(speedInKph); const rotationAngle = START_ANGLE + ((displaySpeed / MAX_SPEED) * ANGLE_RANGE); needleElement.style.transform = `rotate(${rotationAngle}deg)`; speedValueElement.classList.toggle('overspeed', currentAlertLimit !== null && Math.round(speedInKph) > currentAlertLimit); } else { lastKnownSpeed = 0; speedValueElement.textContent = '0'; needleElement.style.transform = `rotate(${START_ANGLE}deg)`; speedValueElement.classList.remove('overspeed'); } 
            }
            function getActiveAlertDistance() { return settings.smartDistanceEnabled ? Math.max(300, Math.min(1500, lastKnownSpeed * 10)) : settings.alertDistance; }

            // --- MODIFIED (Language): checkNearbyCameras now uses translation object for TTS ---
            function checkNearbyCameras(currentPosition) {
                if (!settings.alertsEnabled || isPermissionErrorActive) {
                    hideAlert(); return;
                }
                const { latitude: userLat, longitude: userLon, heading: userHeading, speed: userSpeed } = currentPosition.coords;
                const t = translations[settings.language];

                if (isAlertingForCameraId !== null) {
                    const activeCamera = cameraData.find(c => c.id === isAlertingForCameraId);
                    if (activeCamera) {
                        const currentDistanceToCamera = calculateDistance(userLat, userLon, activeCamera.lat, activeCamera.lon);
                        const currentBearingToCamera = calculateBearing(userLat, userLon, activeCamera.lat, activeCamera.lon);
                        let passed = (currentDistanceToCamera > lastDistanceToAlertingCamera + 5) || (lastBearingToCamera !== null && Math.min(Math.abs(currentBearingToCamera - lastBearingToCamera), 360 - Math.abs(currentBearingToCamera - lastBearingToCamera)) > 90);

                        if (passed) {
                            speak(t.ttsPassed, true);
                            hideAlert();
                            return;
                        } else {
                           showAlert(currentDistanceToCamera, activeCamera.limit);
                           lastDistanceToAlertingCamera = currentDistanceToCamera;
                           lastBearingToCamera = currentBearingToCamera;
                           
                           const roundedDistance = Math.round(currentDistanceToCamera / 100) * 100;
                           const isOverspeeding = Math.round(lastKnownSpeed) > activeCamera.limit;
                           let shouldAnnounce = false;

                           if (roundedDistance > 0 && !announcedDistances.has(roundedDistance)) {
                               if (isOverspeeding || (currentDistanceToCamera > 500 && announcedDistances.size === 0) || currentDistanceToCamera <= 500) {
                                   shouldAnnounce = true;
                               }
                           }
                           
                           if (shouldAnnounce) {
                               let distanceText = formatDistanceText(roundedDistance, settings.language);
                               let speechText = distanceText;
                               if (isOverspeeding) speechText += t.ttsOverspeed;
                               speak(speechText);
                               announcedDistances.add(roundedDistance);
                           }
                           return; 
                        }
                    } else { hideAlert(); }
                }

                if (userHeading === null || (userSpeed * 3.6) < 1) { hideAlert(); return; }
                
                let closestCameraInProximity = null, minDistance = Infinity;
                for (const camera of cameraData) {
                    const distance = calculateDistance(userLat, userLon, camera.lat, camera.lon);
                    if (distance < getActiveAlertDistance() && isMovingTowards(userLat, userLon, camera.lat, camera.lon, userHeading, lastKnownSpeed) && distance < minDistance) {
                        minDistance = distance;
                        closestCameraInProximity = camera;
                    }
                }
                
                if (closestCameraInProximity) {
                    if (alertCandidate.cameraId === closestCameraInProximity.id) alertCandidate.confirmCount++;
                    else {
                        alertCandidate.cameraId = closestCameraInProximity.id;
                        alertCandidate.confirmCount = 1;
                    }
                    if (alertCandidate.confirmCount >= CONFIRMATION_THRESHOLD && isAlertingForCameraId === null) {
                        isAlertingForCameraId = closestCameraInProximity.id;
                        lastDistanceToAlertingCamera = minDistance;
                        lastBearingToCamera = calculateBearing(userLat, userLon, closestCameraInProximity.lat, closestCameraInProximity.lon);
                        showAlert(minDistance, closestCameraInProximity.limit);
                        speak(t.ttsIntro(closestCameraInProximity.limit));
                    }
                } else {
                    if (isAlertingForCameraId === null) hideAlert();
                    alertCandidate = { cameraId: null, confirmCount: 0 };
                }
            }

            function showCustomAlert(title, message, type = 'error', duration = 6000) {
                // ... (function is unchanged)
                clearTimeout(customAlertTimer);
                unifiedAlertElement.classList.remove('alert-error', 'alert-success');
                if (type) unifiedAlertElement.classList.add(`alert-${type}`);
                alertTitleElement.textContent = title;
                alertBodyElement.innerHTML = `<span>${message}</span>`;
                unifiedAlertElement.style.display = 'block';

                if (duration > 0) {
                    customAlertTimer = setTimeout(() => {
                        unifiedAlertElement.classList.remove(`alert-${type}`);
                        if (isCameraAlertActive) {
                            showAlert(lastCameraInfo.distance, lastCameraInfo.limit, true);
                        } else {
                            unifiedAlertElement.style.display = 'none';
                        }
                    }, duration);
                }
            }
            
            // --- MODIFIED (Language): showAlert now uses translation object ---
            function showAlert(distance, limit, forceDisplay = false) {
                isCameraAlertActive = true;
                lastCameraInfo = { distance, limit };
                if (!forceDisplay && (unifiedAlertElement.classList.contains('alert-error') || unifiedAlertElement.classList.contains('alert-success'))) return;
                
                const t = translations[settings.language];
                unifiedAlertElement.classList.remove('alert-error', 'alert-success');
                currentAlertLimit = limit;
                let distanceText = distance > 1000 ? `${(distance / 1000).toFixed(1)} ${t.kmUnit}` : `${Math.round(distance)} ${t.mUnit}`;
                
                alertTitleElement.textContent = t.alertTitle;
                alertBodyElement.innerHTML = `<span>${t.alertDistance}: ${distanceText}</span><span>${t.alertSpeedLimit}: ${limit} km/h</span>`;
                unifiedAlertElement.style.display = 'block';
                speedLimitSignElement.textContent = limit;
                speedLimitSignElement.classList.add('visible');
            }
            
            function hideAlert() {
                // ... (function is unchanged)
                isCameraAlertActive = false;
                if (unifiedAlertElement.style.display === 'block' && !isPermissionErrorActive) {
                     if (!unifiedAlertElement.classList.contains('alert-error') && !unifiedAlertElement.classList.contains('alert-success')) {
                        unifiedAlertElement.style.display = 'none';
                     }
                }
                currentAlertLimit = null; 
                isAlertingForCameraId = null;
                lastBearingToCamera = null;
                alertCandidate = { cameraId: null, confirmCount: 0 };
                lastDistanceToAlertingCamera = Infinity;
                announcedDistances.clear(); 
                speedValueElement.classList.remove('overspeed');
                speedLimitSignElement.classList.remove('visible');
            }

            function handleError(error) { 
                // ... (function is unchanged, errors are technical and not translated for simplicity)
                 let message; 
                switch (error.code) { 
                    case error.PERMISSION_DENIED: 
                        isPermissionErrorActive = true;
                        message = "請啟用定位服務以使用完整功能。/ Please enable location services."; 
                        showCustomAlert('定位權限錯誤 / Location Permission Error', message, 'error', 0);
                        break; 
                    case error.POSITION_UNAVAILABLE: 
                        message = "目前無法取得您的位置資訊。/ Could not get location."; 
                        showCustomAlert('定位錯誤 / Location Error', message, 'error');
                        break; 
                    case error.TIMEOUT: 
                        message = "取得位置資訊超時。/ Location request timed out."; 
                        showCustomAlert('定位錯誤 / Location Error', message, 'error');
                        break; 
                    default: 
                        message = "發生未知的定位錯誤。/ An unknown location error occurred."; 
                        showCustomAlert('定位錯誤 / Location Error', message, 'error');
                        break; 
                } 
            }
            
            function handlePositionUpdate(position) {
                // ... (function is unchanged)
                if (isPermissionErrorActive) {
                    isPermissionErrorActive = false;
                    unifiedAlertElement.style.display = 'none';
                }
                
                positionHistory.push(position);
                if (positionHistory.length > MAX_HISTORY_POINTS) {
                    positionHistory.shift();
                }

                const smoothedPosition = getSmoothedPosition(position);

                updateSpeed(smoothedPosition); 
                if (cameraData.length > 0) {
                    checkNearbyCameras(smoothedPosition); 
                }
            }

            // --- MODIFIED (Language): `speak` now sets utterance language dynamically ---
            function speak(text, interrupt = false) {
                if (!settings.soundEnabled || !hasInteracted || !('speechSynthesis' in window)) return;
                if (interrupt && isSpeaking) {
                    speechSynthesis.cancel();
                    speechQueue = [];
                }
                speechQueue.push(text);
                processSpeechQueue();
            }

            function processSpeechQueue() {
                if (isSpeaking || speechQueue.length === 0) return;
                isSpeaking = true;
                const textToSpeak = speechQueue.shift();
                const utterance = new SpeechSynthesisUtterance(textToSpeak);
                utterance.lang = settings.language === 'en' ? 'en-US' : 'zh-TW';
                utterance.rate = 1.1;
                
                utterance.onend = () => { isSpeaking = false; processSpeechQueue(); };
                utterance.onerror = (event) => { console.error('Speech synthesis error:', event.error); isSpeaking = false; processSpeechQueue(); };
                speechSynthesis.speak(utterance);
            }
            
            function getSmoothedPosition(fallbackPosition) {
                // ... (function is unchanged)
                if (positionHistory.length < 2) return fallbackPosition;
                let avgLat = 0, avgLon = 0, avgSpeed = 0, avgHeading = 0;
                let validReadings = 0;
                for (const pos of positionHistory) {
                    if (pos.coords.speed !== null && pos.coords.heading !== null) {
                        avgLat += pos.coords.latitude;
                        avgLon += pos.coords.longitude;
                        avgSpeed += pos.coords.speed;
                        avgHeading += pos.coords.heading;
                        validReadings++;
                    }
                }
                if (validReadings === 0) return fallbackPosition;
                return {
                    coords: {
                        latitude: avgLat / validReadings,
                        longitude: avgLon / validReadings,
                        speed: avgSpeed / validReadings,
                        heading: avgHeading / validReadings,
                        accuracy: fallbackPosition.coords.accuracy 
                    }
                };
            }

            function getDynamicToleranceAngle(speedKph) {
                // ... (function is unchanged)
                if (speedKph > 80) return 20;
                if (speedKph > 40) return 25;
                return 30;
            }

            function createTicks() { 
                // ... (function is unchanged)
                gaugeElement.innerHTML = ''; const container = document.querySelector('.speedometer-wrapper'); if (!container) return; const diameter = Math.min(container.offsetWidth, container.offsetHeight); if (diameter === 0) return; const radius = diameter / 2; const centerX = container.offsetWidth / 2, centerY = container.offsetHeight / 2; const numberRadius = radius - (diameter > 300 ? 40 : 30); const tickOuterRadius = radius - 5; const totalTickCount = (MAX_SPEED / 20) * 2; for (let i = 0; i <= totalTickCount; i++) { const angle = START_ANGLE + (i / totalTickCount) * ANGLE_RANGE; const isMajorTick = i % 2 === 0; const mathAngleRad = (angle - 90) * (Math.PI / 180); const tick = document.createElement('div'); tick.className = isMajorTick ? 'tick major' : 'tick minor'; const tickStartRadius = isMajorTick ? (tickOuterRadius - 15) : (tickOuterRadius - 10); const tickCenterRadius = (tickStartRadius + tickOuterRadius) / 2; tick.style.left = `${centerX + tickCenterRadius * Math.cos(mathAngleRad)}px`; tick.style.top = `${centerY + tickCenterRadius * Math.sin(mathAngleRad)}px`; tick.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`; gaugeElement.appendChild(tick); if (isMajorTick) { const tickValue = Math.round((i / totalTickCount) * MAX_SPEED); const numX = centerX + numberRadius * Math.cos(mathAngleRad); const numY = centerY + numberRadius * Math.sin(mathAngleRad); const tickNumber = document.createElement('div'); tickNumber.className = 'tick-number'; tickNumber.innerText = tickValue; tickNumber.style.left = `${numX}px`; tickNumber.style.top = `${numY}px`; gaugeElement.appendChild(tickNumber); } } 
            }
            
            // --- MODIFIED (Language): updateClock now uses translation object for AM/PM ---
            function updateClock() {
                const t = translations[settings.language];
                const now = new Date();
                const minutes = String(now.getMinutes()).padStart(2, '0');
                let hours = now.getHours();
                const period = hours >= 12 ? t.pm : t.am;
                hours = hours % 12 || 12;
                clockElement.textContent = `${period} ${hours}:${minutes}`;
            }

            // --- NEW (Language): Helper to format distance for TTS ---
            function formatDistanceText(distance, lang) {
                const t = translations[lang];
                if (distance >= 1000) {
                    return `${distance / 1000} ${t.kmUnit}`;
                }
                return `${distance} ${t.mUnit}`;
            }

            function calculateDistance(lat1, lon1, lat2, lon2) { const R = 6371e3; const φ1 = lat1 * Math.PI / 180, φ2 = lat2 * Math.PI / 180, Δφ = (lat2 - lat1) * Math.PI / 180, Δλ = (lon2 - lon1) * Math.PI / 180; const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2); const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return R * c; }
            function calculateBearing(lat1, lon1, lat2, lon2) { const φ1 = lat1 * Math.PI / 180, φ2 = lat2 * Math.PI / 180, λ1 = lon1 * Math.PI / 180, λ2 = lon2 * Math.PI / 180; const y = Math.sin(λ2 - λ1) * Math.cos(φ2); const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(λ2 - λ1); return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360; }
            function isMovingTowards(userLat, userLon, targetLat, targetLon, userHeading, speedKph) { const bearingToTarget = calculateBearing(userLat, userLon, targetLat, targetLon); const angleDifference = Math.abs(bearingToTarget - userHeading); const toleranceAngle = getDynamicToleranceAngle(speedKph); return Math.min(angleDifference, 360 - angleDifference) <= toleranceAngle; }

            initializeUI();
            startBackgroundServices();
        };
    </script>
</body>
</html>